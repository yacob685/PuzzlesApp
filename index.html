<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Nexus - Multiplayer Memory</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* Custom Gold/Dark Theme for Aesthetics */
        :root {
            --primary: #FFC72C; /* Gold */
            --secondary: #1F2937; /* Dark Gray */
            --background: #0F172A; /* Deep Blue/Black */
        }

        body { background-color: var(--background); color: #F3F4F6; font-family: 'Inter', sans-serif; }
        
        /* Utility Classes for Tailwind to pick up dynamic grid classes */
        .grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        .grid-cols-6 { grid-template-columns: repeat(6, minmax(0, 1fr)); }
        .grid-cols-8 { grid-template-columns: repeat(8, minmax(0, 1fr)); }

        .btn-primary { 
            @apply bg-primary text-secondary font-bold py-3 px-6 rounded-lg shadow-lg transition duration-200 hover:bg-yellow-400 hover:shadow-xl; 
        }
        .btn-secondary { 
            @apply bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-200 hover:bg-gray-500 hover:shadow-xl; 
        }
        .card { 
            transition: transform 0.6s, background-color 0.3s, opacity 0.3s;
            transform-style: preserve-3d;
            perspective: 1000px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
        }
        .card:not(.bg-green-700):hover {
            box-shadow: 0 8px 12px rgba(255, 199, 44, 0.5); /* Gold hover shadow */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">
    <div id="app-container" class="flex-grow flex flex-col max-w-4xl mx-auto w-full p-4 sm:p-6 lg:p-8">
        <!-- Navigation Bar -->
        <nav id="nav-bar" class="flex justify-between items-center p-4 bg-secondary rounded-xl shadow-2xl mb-6">
            <!-- Content will be rendered by renderNavBar() -->
        </nav>

        <!-- Main Content Area -->
        <main id="content-area" class="flex-grow bg-gray-800 rounded-xl shadow-2xl p-6">
            <!-- Page content will be rendered here -->
            <div class="text-center text-gray-400">Loading application...</div>
        </main>

        <!-- Message/Modal Area -->
        <div id="message-container" class="fixed bottom-4 right-4 z-50"></div>
    </div>

    <script type="module">
        // =================================================================
        // Firebase Modular Imports
        // =================================================================
        import { initializeApp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, collection, query, where, getDocs, runTransaction, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // =================================================================
        // Global State & Constants
        // =================================================================

        let db;
        let auth;
        const ROOM_COLLECTION_PATH = (appId) => `artifacts/${appId}/public/data/memoryRooms`;
        const ROOM_CODE_LENGTH = 5;
        const MAX_PLAYERS = 2; // Fixed max players for simplicity

        let AppState = {
            page: 'home',
            isAuthReady: false,
            userId: null,
            userName: null,
            db: null,
            appId: null,

            // Multiplayer State
            roomId: null,
            roomCode: null,
            isHost: false,
            roomRef: null,
            currentRoom: null, // Holds the live room data from onSnapshot
            unsubscribeRoom: null, // Listener cleanup function

            // Single Player State
            singlePlayer: {
                level: 1,
                gridSize: 4,
                puzzleGrid: [], // { index, value }
                flippedCards: [], // Card indices that are currently flipped
                matchedCards: {}, // { index: true }
                lastFlipTime: 0,
                score: 0,
                scoreMultiplier: 100
            }
        };

        // =================================================================
        // UI Rendering Functions
        // =================================================================

        const renderApp = () => {
            renderNavBar();
            renderPage();
        };

        const renderNavBar = () => {
            const navBar = document.getElementById('nav-bar');
            let navContent = `
                <h1 class="text-2xl font-extrabold text-primary">Puzzle Nexus</h1>
                <div class="flex items-center space-x-4">
            `;

            if (AppState.userId) {
                // Show user info
                navContent += `<span class="text-sm text-gray-400 hidden sm:inline">User: <span class="text-white font-mono">${AppState.userId.substring(0, 8)}...</span></span>`;
            }

            // Navigation buttons
            if (AppState.page !== 'home' && !AppState.roomId) {
                navContent += `<button onclick="navTo('home')" class="btn-secondary py-2 px-4 text-sm">Home</button>`;
            }

            if (AppState.roomId) {
                 navContent += `<button onclick="leaveRoom()" class="btn-secondary py-2 px-4 text-sm bg-red-600 hover:bg-red-500">
                    <i class="fa-solid fa-right-from-bracket"></i> Leave Room
                </button>`;
            }
            
            navContent += `</div>`;
            navBar.innerHTML = navContent;
        };

        const renderPage = () => {
            const contentArea = document.getElementById('content-area');
            let html = '';

            switch (AppState.page) {
                case 'home':
                    html = renderHomePage();
                    break;
                case 'single-player-menu':
                    html = renderSinglePlayerMenu();
                    break;
                case 'multiplayer-menu':
                    html = renderMultiplayerMenu();
                    break;
                case 'game':
                    html = renderSinglePlayerGame();
                    break;
                case 'multiplayer-lobby':
                    html = renderMultiplayerLobby();
                    break;
                case 'multiplayer-game':
                    html = renderMultiplayerGame();
                    break;
                default:
                    html = `<div class="text-center text-lg mt-10">404 | Page not found.</div>`;
            }

            contentArea.innerHTML = html;

            // Re-render the single-player grid if needed after the container is added
            if (AppState.page === 'game') {
                renderPuzzleGrid(AppState.singlePlayer);
            }

            // Re-render the multiplayer grid if needed (listener usually handles this)
            if (AppState.page === 'multiplayer-game' && AppState.currentRoom) {
                renderMultiplayerPuzzleGrid(AppState.currentRoom);
            }
        };

        const renderHomePage = () => `
            <div class="text-center py-12">
                <h2 class="text-4xl font-bold mb-4 text-primary">Welcome to Puzzle Nexus!</h2>
                <p class="text-xl text-gray-300 mb-8">Test your memory against yourself or a friend.</p>
                <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4">
                    <button onclick="navTo('single-player-menu')" class="btn-primary">
                        <i class="fa-solid fa-user"></i> Single Player
                    </button>
                    <button onclick="navTo('multiplayer-menu')" class="btn-secondary">
                        <i class="fa-solid fa-users"></i> Multiplayer
                    </button>
                </div>
            </div>
        `;

        const renderSinglePlayerMenu = () => `
            <div class="text-center py-8">
                <h2 class="text-3xl font-bold mb-6 text-primary">Single Player Mode</h2>
                <p class="text-gray-400 mb-8">Click start to begin the memory challenge. The grid size increases with each level!</p>
                <button onclick="startGame()" class="btn-primary">
                    <i class="fa-solid fa-play"></i> Start Game (Level ${AppState.singlePlayer.level}, ${AppState.singlePlayer.gridSize}x${AppState.singlePlayer.gridSize})
                </button>
            </div>
        `;

        const renderSinglePlayerGame = () => `
            <div class="flex flex-col items-center">
                <div class="flex justify-between w-full max-w-md mb-4 text-lg font-mono">
                    <span class="text-gray-300">Level: <span class="text-primary">${AppState.singlePlayer.level}</span></span>
                    <span class="text-gray-300">Score: <span class="text-primary">${AppState.singlePlayer.score}</span></span>
                </div>
                <div id="puzzle-grid-container" class="grid grid-cols-${AppState.singlePlayer.gridSize} gap-2 p-4 max-w-lg w-full bg-gray-700 rounded-lg shadow-xl">
                    <!-- Grid rendered by renderPuzzleGrid -->
                </div>
                <div class="mt-8 space-x-4">
                    <button onclick="resetSinglePlayerGame()" class="btn-secondary bg-red-600 hover:bg-red-500">
                        <i class="fa-solid fa-arrows-rotate"></i> Restart Level
                    </button>
                    <button id="next-level-btn" onclick="nextSinglePlayerLevel()" class="btn-primary opacity-50 cursor-not-allowed" disabled>
                        <i class="fa-solid fa-chevron-right"></i> Next Level
                    </button>
                </div>
            </div>
        `;

        const renderMultiplayerMenu = () => `
            <div class="text-center py-8">
                <h2 class="text-3xl font-bold mb-6 text-primary">Multiplayer Mode</h2>
                <p class="text-gray-400 mb-8">Create a room to host a game or join an existing one with a code.</p>
                
                <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 mb-10">
                    <button onclick="createRoom()" class="btn-primary">
                        <i class="fa-solid fa-plus-circle"></i> Create Room
                    </button>
                </div>

                <div class="max-w-md mx-auto p-6 bg-gray-700 rounded-lg shadow-inner">
                    <h3 class="text-xl font-semibold mb-4 text-white">Join Room</h3>
                    <form onsubmit="handleJoinForm(event)" class="flex flex-col space-y-3">
                        <input type="text" id="room-code-input" placeholder="Enter 5-digit Room Code" 
                               class="p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 uppercase tracking-widest text-center focus:ring-primary focus:border-primary border-transparent border-2 transition" 
                               maxlength="${ROOM_CODE_LENGTH}" required>
                        <button type="submit" class="btn-secondary">
                            <i class="fa-solid fa-door-open"></i> Join Game
                        </button>
                    </form>
                </div>
            </div>
        `;

        const renderMultiplayerLobby = () => {
            const isHost = AppState.isHost;
            const players = AppState.currentRoom ? Object.values(AppState.currentRoom.players) : [];
            const canStart = isHost && players.length >= 2;

            return `
                <div class="max-w-xl mx-auto py-4">
                    <h2 class="text-3xl font-bold mb-6 text-primary text-center">Game Lobby</h2>

                    <div class="bg-gray-700 p-6 rounded-lg shadow-xl mb-6">
                        <div class="flex justify-center items-center mb-4 space-x-2">
                            <span class="text-2xl font-mono tracking-widest text-white">
                                ROOM CODE: <span id="room-code-display" class="text-primary font-extrabold">${AppState.roomCode}</span>
                            </span>
                            <button onclick="copyRoomCode()" class="text-gray-400 hover:text-primary transition">
                                <i class="fa-solid fa-copy"></i>
                            </button>
                        </div>
                        <p class="text-center text-gray-400 text-sm">Share this code with a friend to join!</p>
                    </div>

                    <div class="flex space-x-6">
                        <!-- Player List -->
                        <div class="flex-1 bg-gray-700 p-4 rounded-lg shadow-inner">
                            <h3 class="text-xl font-semibold mb-3 text-white">Players (${players.length}/${MAX_PLAYERS})</h3>
                            <ul id="multiplayer-player-list">
                                <!-- Players dynamically updated by listener -->
                            </ul>
                        </div>

                        <!-- Chat Area -->
                        <div class="flex-1 bg-gray-700 p-4 rounded-lg shadow-inner flex flex-col h-64">
                            <h3 class="text-xl font-semibold mb-3 text-white">Chat</h3>
                            <div id="multiplayer-chat-messages" class="flex-grow overflow-y-auto mb-3 p-2 bg-gray-800 rounded">
                                <!-- Chat messages dynamically updated by listener -->
                            </div>
                            <div class="flex">
                                <input type="text" id="chat-input" placeholder="Type a message..." class="flex-grow p-2 rounded-l-lg bg-gray-600 text-white placeholder-gray-400 border-transparent focus:ring-primary focus:border-primary border-2">
                                <button onclick="sendChat()" class="bg-primary text-secondary p-2 rounded-r-lg hover:bg-yellow-400">
                                    <i class="fa-solid fa-paper-plane"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="text-center mt-6">
                        ${isHost 
                            ? `<button onclick="multiplayerStartGame()" class="btn-primary ${canStart ? '' : 'opacity-50 cursor-not-allowed'}" ${canStart ? '' : 'disabled'}>
                                    <i class="fa-solid fa-gamepad"></i> ${canStart ? 'Start Game' : 'Waiting for 2 players...'}
                                </button>`
                            : `<p class="text-lg text-gray-300">Waiting for the host to start the game...</p>`
                        }
                    </div>
                </div>
            `;
        };

        const renderMultiplayerGame = () => {
            return `
                <div class="flex flex-col lg:flex-row max-w-full mx-auto space-y-6 lg:space-y-0 lg:space-x-6">
                    <!-- Game Grid & Status -->
                    <div class="lg:w-2/3">
                        <div class="bg-gray-700 p-4 rounded-xl shadow-2xl mb-4 text-center">
                            <p id="multiplayer-turn-message" class="text-xl font-semibold text-white">
                                <!-- Turn message updated by listener -->
                            </p>
                        </div>
                        <div id="multiplayer-grid-container" class="max-w-full aspect-square mx-auto bg-gray-700 rounded-xl shadow-2xl p-4">
                            <!-- Grid rendered by renderMultiplayerPuzzleGrid -->
                        </div>
                    </div>

                    <!-- Sidebar: Scores & Chat -->
                    <div class="lg:w-1/3 flex flex-col space-y-6">
                        <!-- Scoreboard -->
                        <div class="bg-gray-700 p-4 rounded-lg shadow-inner">
                            <h3 class="text-xl font-semibold mb-3 text-white">Scoreboard</h3>
                            <ul id="multiplayer-player-list">
                                <!-- Scores dynamically updated by listener -->
                            </ul>
                        </div>

                        <!-- Chat Area (reused from lobby) -->
                        <div class="bg-gray-700 p-4 rounded-lg shadow-inner flex flex-col flex-grow">
                            <h3 class="text-xl font-semibold mb-3 text-white">Chat</h3>
                            <div id="multiplayer-chat-messages" class="flex-grow overflow-y-auto mb-3 p-2 bg-gray-800 rounded min-h-32">
                                <!-- Chat messages dynamically updated by listener -->
                            </div>
                            <div class="flex">
                                <input type="text" id="chat-input" placeholder="Type a message..." class="flex-grow p-2 rounded-l-lg bg-gray-600 text-white placeholder-gray-400 border-transparent focus:ring-primary focus:border-primary border-2">
                                <button onclick="sendChat()" class="bg-primary text-secondary p-2 rounded-r-lg hover:bg-yellow-400">
                                    <i class="fa-solid fa-paper-plane"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        };

        const showMessage = (message, type = 'Info') => {
            const container = document.getElementById('message-container');
            const alertClasses = {
                'Info': 'bg-blue-500',
                'Success': 'bg-green-500',
                'Warning': 'bg-yellow-500',
                'Error': 'bg-red-600',
                'Fatal Error': 'bg-red-800'
            };
            
            const alert = document.createElement('div');
            alert.className = `p-3 rounded-lg shadow-xl text-white font-semibold mb-2 ${alertClasses[type] || alertClasses['Info']} transition transform translate-x-full opacity-0`;
            alert.innerHTML = `<strong>${type}:</strong> ${message}`;
            container.appendChild(alert);

            // Animate in
            setTimeout(() => {
                alert.classList.remove('translate-x-full', 'opacity-0');
                alert.classList.add('translate-x-0', 'opacity-100');
            }, 10);

            // Animate out and remove
            setTimeout(() => {
                alert.classList.remove('translate-x-0', 'opacity-100');
                alert.classList.add('translate-x-full', 'opacity-0');
                alert.addEventListener('transitionend', () => alert.remove());
            }, 5000);
        };

        const navTo = (page) => {
            AppState.page = page;
            renderApp();
        };

        // =================================================================
        // Single Player Game Logic
        // =================================================================

        const generateGameGrid = (size) => {
            const totalCells = size * size;
            const numPairs = totalCells / 2;
            // Use numbers 1-N as card values
            let values = [];
            for (let i = 1; i <= numPairs; i++) {
                values.push(i, i);
            }
            // Shuffle (Fisher-Yates)
            for (let i = values.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [values[i], values[j]] = [values[j], values[i]];
            }
            return values.map((value, index) => ({ index, value }));
        };

        const startGame = () => {
             // Reset for a fresh start at level 1
             AppState.singlePlayer.level = 1;
             AppState.singlePlayer.gridSize = 4;
             AppState.singlePlayer.score = 0;
             resetSinglePlayerGame();
        };

        const resetSinglePlayerGame = () => {
            const sp = AppState.singlePlayer;
            sp.puzzleGrid = generateGameGrid(sp.gridSize);
            sp.flippedCards = [];
            sp.matchedCards = {};
            sp.lastFlipTime = 0;
            
            // Re-render UI
            navTo('game');
            const nextLevelBtn = document.getElementById('next-level-btn');
            if (nextLevelBtn) {
                nextLevelBtn.classList.add('opacity-50', 'cursor-not-allowed');
                nextLevelBtn.disabled = true;
            }
        };

        const nextSinglePlayerLevel = () => {
            const sp = AppState.singlePlayer;
            sp.level += 1;
            sp.gridSize = sp.level === 2 ? 6 : sp.level === 3 ? 8 : 4; // Simple level progression
            resetSinglePlayerGame();
        };


        const handleSinglePlayerClick = (cardIndex) => {
            const sp = AppState.singlePlayer;
            
            // Check if game is waiting for flip-back
            if (Date.now() - sp.lastFlipTime < 500 && sp.flippedCards.length === 2) {
                return;
            }

            // Card is already matched or currently flipped
            if (sp.matchedCards[cardIndex] || sp.flippedCards.includes(cardIndex)) {
                return;
            }
            
            // Flip the card
            sp.flippedCards.push(cardIndex);
            
            if (sp.flippedCards.length === 2) {
                sp.lastFlipTime = Date.now();
                const [index1, index2] = sp.flippedCards;
                const value1 = sp.puzzleGrid.find(c => c.index === index1).value;
                const value2 = sp.puzzleGrid.find(c => c.index === index2).value;

                if (value1 === value2) {
                    // Match found
                    sp.matchedCards[index1] = true;
                    sp.matchedCards[index2] = true;
                    sp.score += sp.scoreMultiplier;
                    sp.flippedCards = []; // Clear matched cards immediately
                    
                    const nextLevelBtn = document.getElementById('next-level-btn');
                    if (Object.keys(sp.matchedCards).length === sp.puzzleGrid.length) {
                        showMessage(`Level ${sp.level} complete! Score: ${sp.score}`, 'Success');
                        if (nextLevelBtn) {
                            nextLevelBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                            nextLevelBtn.disabled = false;
                        }
                    }
                } else {
                    // No match, schedule flip back
                    setTimeout(() => {
                        sp.flippedCards = [];
                        renderPuzzleGrid(sp); // Re-render to flip back
                    }, 1000); // 1 second visibility
                }
            }

            renderPuzzleGrid(sp);
        };

        const renderPuzzleGrid = (sp) => {
            const gridContainer = document.getElementById('puzzle-grid-container');
            if (!gridContainer || sp.puzzleGrid.length === 0) return;

            gridContainer.className = `grid grid-cols-${sp.gridSize} gap-2 p-4`;
            gridContainer.innerHTML = sp.puzzleGrid.map(card => {
                const isFlipped = sp.flippedCards.includes(card.index);
                const isMatched = sp.matchedCards[card.index];
                const isClickable = !isFlipped && !isMatched && sp.flippedCards.length < 2;

                let content = '';
                let bgColor = isMatched ? 'bg-green-700' : 'bg-secondary';

                if (isFlipped || isMatched) {
                    content = `<span class="text-3xl font-extrabold text-white">${card.value}</span>`;
                    bgColor = isMatched ? 'bg-green-700' : 'bg-gray-600';
                }

                return `
                    <div class="card aspect-square rounded-lg shadow-xl flex items-center justify-center cursor-pointer transition-all duration-300 transform hover:scale-105 ${bgColor} ${isClickable ? 'hover:shadow-2xl' : 'opacity-70 cursor-default'}"
                         onclick="${isClickable ? `handleSinglePlayerClick(${card.index})` : ''}">
                        ${content}
                    </div>
                `;
            }).join('');

            // Update score display immediately
            const scoreElement = document.querySelector('.font-mono span:last-child');
            if (scoreElement) scoreElement.textContent = AppState.singlePlayer.score;
        };

        // =================================================================
        // Multiplayer Game Logic (Firestore)
        // =================================================================

        const generateRoomCode = () => {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < ROOM_CODE_LENGTH; i++) {
                code += chars.charAt(Math.floor(Math.random() * (chars.length)));
            }
            return code;
        };

        const createRoom = async () => {
            if (!AppState.db || !AppState.userId) return showMessage('Application not fully initialized.', 'Error');

            // 1. Generate a unique room code
            let roomCode;
            let roomExists = true;
            try {
                while (roomExists) {
                    roomCode = generateRoomCode();
                    const q = query(collection(AppState.db, ROOM_COLLECTION_PATH(AppState.appId)), where('code', '==', roomCode));
                    const querySnapshot = await getDocs(q);
                    if (querySnapshot.empty) {
                        roomExists = false;
                    }
                }
            } catch (error) {
                console.error("Error generating unique code:", error);
                return showMessage('Failed to ensure unique room code.', 'Error');
            }


            // 2. Create the room document
            const newRoomRef = doc(collection(AppState.db, ROOM_COLLECTION_PATH(AppState.appId)));
            const initialRoomData = {
                code: roomCode,
                hostId: AppState.userId,
                status: 'waiting', 
                maxPlayers: MAX_PLAYERS,
                players: {
                    [AppState.userId]: {
                        name: AppState.userName,
                        score: 0,
                        userId: AppState.userId,
                        isHost: true
                    }
                },
                gameConfig: { gridSize: 4, level: 1 },
                turnOrder: [AppState.userId],
                currentPlayerId: AppState.userId,
                puzzleGrid: [], 
                flippedCards: [], 
                matchedCards: {}, 
                lastFlipTime: Date.now(),
                chat: [],
                createdAt: Date.now()
            };

            try {
                await setDoc(newRoomRef, initialRoomData);
                AppState.roomId = newRoomRef.id;
                AppState.roomCode = roomCode;
                AppState.isHost = true;
                AppState.roomRef = newRoomRef;

                showMessage(`Room created with code: ${roomCode}`, 'Success');
                navTo('multiplayer-lobby');
                setupRoomListener(); 
            } catch (error) {
                console.error("Error creating room:", error);
                showMessage('Failed to create room. See console.', 'Error');
            }
        };

        const joinRoomByCode = async (code) => {
            if (!AppState.db || !AppState.userId) return showMessage('Application not fully initialized.', 'Error');
            if (!code) return showMessage('Room code cannot be empty.', 'Error');

            const roomCode = code.toUpperCase().trim();
            const roomsCollection = collection(AppState.db, ROOM_COLLECTION_PATH(AppState.appId));
            const q = query(roomsCollection, where('code', '==', roomCode));

            try {
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    return showMessage(`No room found with code: ${roomCode}`, 'Error');
                }

                const roomDoc = querySnapshot.docs[0];
                const roomData = roomDoc.data();
                const roomId = roomDoc.id;

                if (roomData.status !== 'waiting' && !roomData.players[AppState.userId]) {
                    return showMessage('This game has already started or finished.', 'Error');
                }
                
                const currentPlayers = Object.keys(roomData.players || {}).length;
                if (currentPlayers >= roomData.maxPlayers && !roomData.players[AppState.userId]) {
                    return showMessage('This room is full.', 'Error');
                }

                if (roomData.players && roomData.players[AppState.userId]) {
                    // Player is already in the room, just re-join/navigate
                    AppState.roomId = roomId;
                    AppState.roomCode = roomCode;
                    AppState.isHost = roomData.hostId === AppState.userId;
                    AppState.roomRef = doc(AppState.db, ROOM_COLLECTION_PATH(AppState.appId), roomId);
                    navTo(roomData.status === 'in-game' ? 'multiplayer-game' : 'multiplayer-lobby');
                    setupRoomListener();
                    showMessage('Welcome back to the room!', 'Info');
                    return;
                }

                // Add player to the room using transaction for safety
                await runTransaction(AppState.db, async (transaction) => {
                    const freshRoomDoc = await transaction.get(roomDoc.ref);
                    if (!freshRoomDoc.exists()) throw new Error("Room document does not exist!");
                    const freshRoomData = freshRoomDoc.data();

                    if (Object.keys(freshRoomData.players || {}).length >= freshRoomData.maxPlayers) {
                         throw new Error("Room is now full.");
                    }

                    const newPlayers = {
                        ...freshRoomData.players,
                        [AppState.userId]: {
                            name: AppState.userName,
                            score: 0,
                            userId: AppState.userId,
                            isHost: false
                        }
                    };
                    const newTurnOrder = [...(freshRoomData.turnOrder || []), AppState.userId];

                    transaction.update(roomDoc.ref, {
                        players: newPlayers,
                        turnOrder: newTurnOrder,
                        chat: [...(freshRoomData.chat || []), {
                            userId: 'system',
                            userName: 'System',
                            message: `${AppState.userName} joined the room.`,
                            timestamp: Date.now()
                        }]
                    });

                    AppState.roomId = roomId;
                    AppState.roomCode = roomCode;
                    AppState.isHost = false;
                    AppState.roomRef = roomDoc.ref;
                    navTo('multiplayer-lobby');
                    showMessage('Successfully joined room!', 'Success');
                    setupRoomListener(); 
                });

            } catch (error) {
                console.error("Error joining room:", error);
                showMessage(`Failed to join room: ${error.message || 'Unknown error'}`, 'Error');
            }
        };

        const handleJoinForm = (event) => {
            event.preventDefault();
            const code = document.getElementById('room-code-input').value;
            joinRoomByCode(code);
        };

        const setupRoomListener = () => {
            if (AppState.unsubscribeRoom) {
                AppState.unsubscribeRoom(); 
            }
            if (!AppState.roomRef) {
                return;
            }

            AppState.unsubscribeRoom = onSnapshot(AppState.roomRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const roomData = docSnapshot.data();
                    AppState.currentRoom = roomData;
                    
                    // Force a page re-render to update player list, chat, etc.
                    if (AppState.page.startsWith('multiplayer')) {
                        renderPage();
                    }

                    // Handle Game State Navigation
                    if (roomData.status === 'in-game' && AppState.page !== 'multiplayer-game') {
                        navTo('multiplayer-game');
                    } else if (roomData.status === 'waiting' && AppState.page !== 'multiplayer-lobby') {
                         if (AppState.page === 'multiplayer-game') {
                            showMessage('Host returned to lobby.', 'Info');
                         }
                         navTo('multiplayer-lobby');
                    }
                    
                    if (AppState.page === 'multiplayer-game' && roomData.status === 'in-game') {
                         renderMultiplayerPuzzleGrid(roomData); // Ensure grid updates
                    }


                } else {
                    // Room deleted or no longer exists
                    if (AppState.unsubscribeRoom) AppState.unsubscribeRoom();
                    AppState.unsubscribeRoom = null;
                    AppState.roomRef = null;
                    AppState.roomId = null;
                    AppState.roomCode = null;
                    AppState.currentRoom = null;
                    AppState.isHost = false;

                    if (AppState.page.startsWith('multiplayer')) {
                        showMessage('The room has been closed or you were removed.', 'Info');
                        navTo('multiplayer-menu');
                    }
                }
            }, (error) => {
                console.error("Firestore Listener Error:", error);
                showMessage('Connection to the room lost. Try rejoining.', 'Error');
            });
        };

        const leaveRoom = async () => {
            if (!AppState.roomRef) {
                navTo('multiplayer-menu');
                return;
            }

            try {
                await runTransaction(AppState.db, async (transaction) => {
                    const roomDoc = await transaction.get(AppState.roomRef);
                    if (!roomDoc.exists()) return;

                    const roomData = roomDoc.data();
                    let players = roomData.players || {};
                    const playerIds = Object.keys(players);

                    if (playerIds.length === 1 && playerIds[0] === AppState.userId) {
                        // Last player leaving, delete the room
                        transaction.delete(AppState.roomRef);
                    } else if (players[AppState.userId]) {
                        // Not the last player, remove current user
                        delete players[AppState.userId];

                        if (AppState.userId === roomData.hostId) {
                            // Host is leaving, appoint a new host
                            const newHostId = Object.keys(players)[0];
                            if (newHostId) {
                                players[newHostId].isHost = true;
                                transaction.update(AppState.roomRef, {
                                    players: players,
                                    hostId: newHostId,
                                    chat: [...(roomData.chat || []), {
                                        userId: 'system',
                                        userName: 'System',
                                        message: `${AppState.userName} left. ${players[newHostId].name} is the new host.`,
                                        timestamp: Date.now()
                                    }]
                                });
                            } else {
                                transaction.delete(AppState.roomRef); // Safety delete if somehow 0 players remain
                            }
                        } else {
                            // Regular player leaving
                            transaction.update(AppState.roomRef, { 
                                players: players,
                                chat: [...(roomData.chat || []), {
                                    userId: 'system',
                                    userName: 'System',
                                    message: `${AppState.userName} left the room.`,
                                    timestamp: Date.now()
                                }]
                            });
                        }
                    }
                });

                // Cleanup local state and UI
                if (AppState.unsubscribeRoom) {
                    AppState.unsubscribeRoom();
                    AppState.unsubscribeRoom = null;
                }
                AppState.roomRef = null;
                AppState.roomId = null;
                AppState.roomCode = null;
                AppState.currentRoom = null;
                AppState.isHost = false;

                showMessage('Left the room.', 'Info');
                navTo('multiplayer-menu');
            } catch (error) {
                console.error("Error leaving room:", error);
                showMessage('Failed to leave room. See console.', 'Error');
            }
        };

        const copyRoomCode = () => {
            const code = AppState.roomCode;
            if (code) {
                const tempInput = document.createElement('input');
                tempInput.value = code;
                document.body.appendChild(tempInput);
                tempInput.select();
                try {
                    document.execCommand('copy');
                    showMessage('Room code copied to clipboard!', 'Info');
                } catch (err) {
                    showMessage('Could not copy text.', 'Error');
                }
                document.body.removeChild(tempInput);
            }
        };

        const sendChat = async () => {
            const chatInput = document.getElementById('chat-input');
            const message = chatInput.value.trim();
            if (!message || !AppState.roomRef) return;

            try {
                await updateDoc(AppState.roomRef, {
                    chat: [
                        ...(AppState.currentRoom.chat || []),
                        {
                            userId: AppState.userId,
                            userName: AppState.userName,
                            message: message,
                            timestamp: Date.now()
                        }
                    ].slice(-100) 
                });
                chatInput.value = ''; 
            } catch (error) {
                console.error("Error sending chat:", error);
                showMessage('Failed to send message.', 'Error');
            }
        };

        const multiplayerStartGame = async () => {
            if (!AppState.roomRef || !AppState.isHost) {
                return showMessage('Only the host can start the game.', 'Error');
            }
            if (Object.keys(AppState.currentRoom.players).length < 2) {
                return showMessage('Need at least 2 players to start.', 'Warning');
            }

            try {
                const gridSize = AppState.currentRoom.gameConfig.gridSize;
                const puzzleGrid = generateGameGrid(gridSize);

                await updateDoc(AppState.roomRef, {
                    status: 'in-game',
                    puzzleGrid: puzzleGrid,
                    flippedCards: [],
                    matchedCards: {},
                    lastFlipTime: Date.now(),
                    currentPlayerId: AppState.currentRoom.turnOrder[0],
                    // Reset scores
                    players: Object.fromEntries(
                        Object.entries(AppState.currentRoom.players).map(([id, player]) => [id, { ...player, score: 0 }])
                    )
                });
                showMessage('Game started!', 'Success');
            } catch (error) {
                console.error("Error starting game:", error);
                showMessage('Failed to start game.', 'Error');
            }
        };

        const getNextPlayerId = (roomData) => {
            const turnOrder = roomData.turnOrder || [];
            if (turnOrder.length === 0) return null;
            const currentIndex = turnOrder.indexOf(roomData.currentPlayerId);
            const nextIndex = (currentIndex + 1) % turnOrder.length;
            return turnOrder[nextIndex];
        };

        const handleMultiplayerClick = async (cardIndex) => {
            if (!AppState.roomRef || AppState.currentRoom.status !== 'in-game') return;

            // Check if it's the current user's turn
            if (AppState.currentRoom.currentPlayerId !== AppState.userId) {
                return showMessage("It's not your turn.", 'Warning');
            }

            const { puzzleGrid, flippedCards, matchedCards } = AppState.currentRoom;

            // Card is already matched or currently flipped
            if (matchedCards[cardIndex] || flippedCards.includes(cardIndex)) {
                return;
            }

            // Use a transaction for the core game logic to ensure atomicity
            try {
                await runTransaction(AppState.db, async (transaction) => {
                    const freshRoomDoc = await transaction.get(AppState.roomRef);
                    if (!freshRoomDoc.exists()) throw new Error("Room does not exist.");
                    const freshRoom = freshRoomDoc.data();

                    if (freshRoom.currentPlayerId !== AppState.userId) return; 

                    let newFlippedCards = [...freshRoom.flippedCards, cardIndex];
                    let newMatchedCards = { ...freshRoom.matchedCards };
                    let newPlayers = { ...freshRoom.players };
                    let status = freshRoom.status;
                    let nextTurn = false;
                    let currentUserId = AppState.userId; // Player who clicked

                    if (newFlippedCards.length === 2) {
                        const [index1, index2] = newFlippedCards;
                        const card1 = freshRoom.puzzleGrid.find(c => c.index === index1);
                        const card2 = freshRoom.puzzleGrid.find(c => c.index === index2);

                        if (card1.value === card2.value) {
                            // Match found
                            newMatchedCards[index1] = true;
                            newMatchedCards[index2] = true;

                            // Update score
                            newPlayers[currentUserId].score += 1;

                            // Check for win condition
                            const allMatched = Object.keys(newMatchedCards).length === freshRoom.puzzleGrid.length;
                            if (allMatched) {
                                status = 'finished';
                            }
                            newFlippedCards = []; // Clear matched cards immediately
                            // Player gets another turn
                        } else {
                            // No match, prepare to switch turn
                            nextTurn = true;
                        }
                    }

                    // Update the document with new state
                    const updatePayload = {
                        flippedCards: newFlippedCards,
                        matchedCards: newMatchedCards,
                        players: newPlayers,
                        status: status,
                        lastFlipTime: Date.now(),
                        currentPlayerId: nextTurn ? getNextPlayerId(freshRoom) : freshRoom.currentPlayerId
                    };
                    
                    transaction.update(AppState.roomRef, updatePayload);


                    // If 2 cards are flipped and no match, schedule the card flip-back and turn switch
                    if (nextTurn) {
                        setTimeout(async () => {
                            // Only update flippedCards back to empty after a delay, the turn switch is already committed
                            try {
                                 const currentDoc = await getDoc(AppState.roomRef);
                                 if (currentDoc.exists() && currentDoc.data().flippedCards.length === 2) {
                                    await updateDoc(AppState.roomRef, { flippedCards: [] });
                                 }
                            } catch(e) { /* Listener handles deleted room or error, just fail silently */ }

                        }, 1000); // 1 second visibility
                    }
                });
            } catch (error) {
                console.error("Transaction failed during card click:", error);
                showMessage("Failed to register click. Try again.", "Error");
            }
        };

        const renderMultiplayerPuzzleGrid = (roomData) => {
            const gridContainer = document.getElementById('multiplayer-grid-container');
            const turnMessageElement = document.getElementById('multiplayer-turn-message');
            
            if (!gridContainer || !roomData.puzzleGrid || roomData.puzzleGrid.length === 0) return;

            const gridSize = roomData.gameConfig.gridSize;
            const isMyTurn = roomData.currentPlayerId === AppState.userId;
            const cards = roomData.puzzleGrid;
            const { flippedCards, matchedCards } = roomData;

            gridContainer.className = `grid grid-cols-${gridSize} gap-2 p-4`;
            gridContainer.innerHTML = cards.map(card => {
                const isFlipped = flippedCards.includes(card.index);
                const isMatched = matchedCards[card.index];
                const isClickable = !isFlipped && !isMatched && isMyTurn && flippedCards.length < 2;

                let content = '';
                let bgColor = 'bg-secondary';
                let cursorStyle = 'cursor-default opacity-70';

                if (isFlipped || isMatched) {
                    content = `<span class="text-3xl font-extrabold text-white">${card.value}</span>`;
                    bgColor = isMatched ? 'bg-green-700' : 'bg-gray-600';
                    cursorStyle = 'cursor-default';
                }
                
                if (isClickable) {
                    cursorStyle = 'cursor-pointer hover:shadow-2xl';
                }

                return `
                    <div class="card aspect-square rounded-lg shadow-xl flex items-center justify-center transition-all duration-300 transform hover:scale-105 ${bgColor} ${cursorStyle}"
                         onclick="${isClickable ? `handleMultiplayerClick(${card.index})` : ''}">
                        ${content}
                    </div>
                `;
            }).join('');

            // Update turn message
            if (turnMessageElement) {
                const currentPlayerName = roomData.players[roomData.currentPlayerId]?.name || 'Unknown';
                if (roomData.status === 'finished') {
                    // Calculate winner
                    const playerArray = Object.values(roomData.players);
                    playerArray.sort((a, b) => b.score - a.score); // Sort descending by score
                    const winner = playerArray[0];
                    turnMessageElement.innerHTML = `<span class="text-primary font-bold">Game Over! Winner: ${winner.name} with ${winner.score} pairs!</span>`;
                    return;
                }
                if (isMyTurn) {
                    turnMessageElement.innerHTML = `<span class="text-primary font-bold">Your Turn!</span> Make your move.`;
                } else {
                    turnMessageElement.innerHTML = `It's <span class="text-primary font-bold">${currentPlayerName}'s</span> turn.`;
                }
            }
        };

        // =================================================================
        // Initialization
        // =================================================================

                  const initApp = async () => {
            try {
                // Enable debug logging for Firestore/Auth
                setLogLevel('debug');

                // 1. Load Configs
                // Place your firebaseConfig object here directly:
                const firebaseConfig = {
                  apiKey: "AIzaSyB-3kAk-lMT3jTny2YIs2R1_0mG-tJlmJI",
                  authDomain: "puzzlesapp.firebaseapp.com",
                  projectId: "puzzlesapp",
                  storageBucket: "puzzlesapp.firebasestorage.app",
                  messagingSenderId: "303461259730",
                  appId: "1:303461259730:web:a1790a976b6d58d71dd00b",
                  measurementId: "G-8YEJEBX0NE"
                };

                const appId = typeof __app_id !== 'undefined' ? __app_id : 'puzzle-nexus-default';
                AppState.appId = appId;

                // 2. Initialize Firebase
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                AppState.db = db;

                // 3. Authenticate
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                // Wait for auth state to settle
                await new Promise(resolve => {
                    const unsubscribe = onAuthStateChanged(auth, (user) => {
                        if (user) {
                            AppState.userId = user.uid;
                            AppState.userName = `Player-${user.uid.substring(0, 4)}`;
                            AppState.isAuthReady = true;
                        }
                        unsubscribe();
                        resolve();
                    });
                });

                // 4. Start App
                renderApp();

            } catch (error) {
                console.error("Initialization Error:", error);
                showMessage('Failed to initialize application. Check console for details.', 'Fatal Error');
            }
        };

        // =================================================================
        // Global Exposure for HTML Calls
        // =================================================================

        // Initial call to start the application
        initApp();

        // Expose functions globally for inline HTML calls
        window.navTo = navTo;
        window.renderNavBar = renderNavBar;
        
        // Multiplayer functions
        window.createRoom = createRoom;
        window.joinRoomByCode = joinRoomByCode;
        window.handleJoinForm = handleJoinForm;
        window.leaveRoom = leaveRoom;
        window.copyRoomCode = copyRoomCode;
        window.sendChat = sendChat;
        window.multiplayerStartGame = multiplayerStartGame;
        window.handleMultiplayerClick = handleMultiplayerClick;
        window.renderMultiplayerPuzzleGrid = renderMultiplayerPuzzleGrid; // Exposed for listener update

        // Single Player functions
        window.startGame = startGame;
        window.resetSinglePlayerGame = resetSinglePlayerGame;
        window.handleSinglePlayerClick = handleSinglePlayerClick;
        window.nextSinglePlayerLevel = nextSinglePlayerLevel;
        window.renderPuzzleGrid = renderPuzzleGrid; // Exposed for single player flip-back logic

    </script>
</body>
</html>
