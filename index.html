<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Nexus: Multiplayer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion, onSnapshot, collection, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase State
        window.firebaseState = {
            db: null,
            auth: null,
            user: null,
            appId: null,
            unsubscribeRoom: null
        };

        // --- FIREBASE INITIALIZATION ---
        const initFirebase = async () => {
            const firebaseConfig = JSON.parse(window.__firebase_config || '{}');
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);
            const appId = window.__app_id || 'default-app';

            window.firebaseState.db = db;
            window.firebaseState.auth = auth;
            window.firebaseState.appId = appId;

            // Auth Flow
            try {
                if (window.__initial_auth_token) {
                    await signInWithCustomToken(auth, window.__initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Auth failed:", error);
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    window.firebaseState.user = user;
                    window.AppState.userId = user.uid;
                    window.initAppLogic(); // Start App after Auth
                }
            });
        };

        initFirebase();
    </script>

    <style>
        /* Custom Theme Colors */
        .text-gold-400 { color: #FFD700; }
        .bg-gold-600 { background-color: #FFC72C; }
        .hover\:bg-gold-700:hover { background-color: #FFB300; }
        .border-gold-400 { border-color: #FFD700; }
        
        .shadow-glow { box-shadow: 0 0 15px rgba(45, 212, 191, 0.3); }
        
        /* Animation Classes */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.3s ease-out forwards; }

        @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .animate-pop { animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #111827; }
        ::-webkit-scrollbar-thumb { background: #374151; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #4b5563; }

        /* Game Board Styles */
        .grid-cell { aspect-ratio: 1; transition: all 0.2s; }
        .grid-cell:active { transform: scale(0.95); }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen font-sans overflow-x-hidden selection:bg-teal-500 selection:text-white">

    <!-- Main App Container -->
    <div id="app" class="min-h-screen flex flex-col">
        <!-- Loading Screen -->
        <div class="flex flex-col items-center justify-center h-screen space-y-4">
            <div class="w-12 h-12 border-4 border-teal-500 border-t-transparent rounded-full animate-spin"></div>
            <div class="text-xl text-teal-400 font-mono animate-pulse">Connecting to Nexus...</div>
        </div>
    </div>

    <!-- Modal Portal -->
    <div id="modal-container"></div>
    
    <!-- Confetti Canvas -->
    <canvas id="confetti-canvas" class="fixed inset-0 pointer-events-none z-50"></canvas>

    <script type="module">
        import { doc, setDoc, getDoc, updateDoc, arrayUnion, onSnapshot, collection, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GAME CONSTANTS ---
        const PUZZLE_NAMES = [
            "Sequential Memory", 
            "Light Switch Logic", 
            "Pattern Simon", 
            "Coming Soon..."
        ];

        // --- APPLICATION STATE ---
        window.AppState = {
            userId: null,
            currentPage: 'loading',
            activeRoom: null,
            roomListener: null,
            
            // Single Player / Local State
            selectedGameId: 0,
            
            // Game State
            gameState: {
                active: false,
                score: 0,
                mistakes: 0,
                level: 1,
                matrix: [], // For Memory
                lights: [], // For Light Switch
                pattern: [], // For Simon
                userPattern: [],
                timer: 0,
                interval: null,
                isDemo: false // True during "memorize" phase
            }
        };

        // --- FIRESTORE SERVICE ---
        const Service = {
            // Helpers
            getDb: () => window.firebaseState.db,
            getUserId: () => window.firebaseState.user.uid,
            getAppId: () => window.firebaseState.appId,
            
            // Room Management
            async createRoom(mode) {
                const code = Math.random().toString(36).substring(2, 6).toUpperCase();
                const roomRef = doc(this.getDb(), 'artifacts', this.getAppId(), 'public', 'data', 'rooms', code);
                
                const roomData = {
                    roomCode: code,
                    hostId: this.getUserId(),
                    mode: mode,
                    status: 'waiting', // waiting, playing
                    gameType: null,
                    gameSeed: null, // For syncing random generation
                    players: [{
                        id: this.getUserId(),
                        name: `Player ${this.getUserId().substr(0,4)}`,
                        score: 0,
                        isHost: true
                    }],
                    chat: []
                };

                await setDoc(roomRef, roomData);
                return code;
            },

            async joinRoom(code) {
                const roomRef = doc(this.getDb(), 'artifacts', this.getAppId(), 'public', 'data', 'rooms', code);
                const snap = await getDoc(roomRef);

                if (!snap.exists()) throw new Error("Room not found");
                
                const room = snap.data();
                if (room.players.some(p => p.id === this.getUserId())) return room; // Already in

                const newPlayer = {
                    id: this.getUserId(),
                    name: `Player ${this.getUserId().substr(0,4)}`,
                    score: 0,
                    isHost: false
                };

                await updateDoc(roomRef, {
                    players: arrayUnion(newPlayer)
                });
                return room;
            },

            async sendChat(code, message) {
                const roomRef = doc(this.getDb(), 'artifacts', this.getAppId(), 'public', 'data', 'rooms', code);
                const chatMsg = {
                    sender: `Player ${this.getUserId().substr(0,4)}`,
                    text: message,
                    time: Date.now(),
                    uid: this.getUserId()
                };
                // Read-modify-write for chat to append simply (or use arrayUnion)
                await updateDoc(roomRef, { chat: arrayUnion(chatMsg) });
            },

            async updateScore(code, score) {
                // In a real app, we'd use a transaction or map update. 
                // For this structure, we read, map, and write.
                const roomRef = doc(this.getDb(), 'artifacts', this.getAppId(), 'public', 'data', 'rooms', code);
                const snap = await getDoc(roomRef);
                if (!snap.exists()) return;
                
                const players = snap.data().players.map(p => {
                    if (p.id === this.getUserId()) return { ...p, score: score };
                    return p;
                });
                
                await updateDoc(roomRef, { players });
            },

            async setGameStatus(code, gameType, status, seed) {
                const roomRef = doc(this.getDb(), 'artifacts', this.getAppId(), 'public', 'data', 'rooms', code);
                await updateDoc(roomRef, {
                    gameType,
                    status, 
                    gameSeed: seed || Math.floor(Math.random() * 100000)
                });
            },

            // Real-time listener
            subscribeToRoom(code, callback) {
                const roomRef = doc(this.getDb(), 'artifacts', this.getAppId(), 'public', 'data', 'rooms', code);
                return onSnapshot(roomRef, (doc) => {
                    if (doc.exists()) callback(doc.data());
                    else callback(null);
                });
            }
        };

        // --- APP LOGIC INITIALIZATION ---
        window.initAppLogic = () => {
            window.navTo('home');
        };

        // --- ROUTING & NAVIGATION ---
        window.navTo = (page) => {
            window.AppState.currentPage = page;
            renderApp();
        };

        // --- GAME LOGIC ---

        // 1. Sequential Memory
        function initSequentialMemory(level, seed) {
            // Seeded random for Multiplayer sync
            const rng = mulberry32(seed ? seed + level : Date.now());
            const size = 3 + Math.floor(level / 3);
            const sequenceLength = 3 + level;
            const sequence = [];
            
            for(let i=0; i<sequenceLength; i++) {
                const r = Math.floor(rng() * size);
                const c = Math.floor(rng() * size);
                sequence.push(`${r}-${c}`);
            }

            return {
                type: 'memory',
                gridSize: size,
                sequence,
                userSequence: [],
                status: 'memorize' // memorize -> input -> success/fail
            };
        }

        // 2. Light Switch (Lights Out)
        function initLightSwitch(level, seed) {
            const rng = mulberry32(seed ? seed + level : Date.now());
            const size = 5;
            // Create solved board (all off) then scramble
            let board = Array(size).fill().map(() => Array(size).fill(false));
            
            // Scramble
            const moves = 5 + level * 2;
            for(let i=0; i<moves; i++) {
                const r = Math.floor(rng() * size);
                const c = Math.floor(rng() * size);
                toggleLights(board, r, c, size);
            }

            return {
                type: 'lights',
                gridSize: size,
                board: board,
                moves: 0,
                status: 'playing'
            };
        }

        function toggleLights(board, r, c, size) {
            const dirs = [[0,0], [0,1], [0,-1], [1,0], [-1,0]];
            dirs.forEach(([dr, dc]) => {
                const nr = r + dr, nc = c + dc;
                if(nr >= 0 && nr < size && nc >= 0 && nc < size) {
                    board[nr][nc] = !board[nr][nc];
                }
            });
        }

        // 3. Simon Pattern
        function initSimon(level, seed) {
            const rng = mulberry32(seed ? seed + level : Date.now());
            const length = 3 + level;
            const sequence = [];
            for(let i=0; i<length; i++) sequence.push(Math.floor(rng() * 4));
            
            return {
                type: 'simon',
                sequence,
                userStep: 0,
                status: 'watch'
            };
        }

        // RNG for Sync
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // --- RENDERERS ---

        function renderHeader() {
            return `
                <nav class="bg-gray-800 border-b border-teal-900 sticky top-0 z-30 shadow-lg">
                    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                        <div class="flex items-center justify-between h-16">
                            <div class="flex items-center gap-3 cursor-pointer" onclick="window.navTo('home')">
                                <i class="fa-solid fa-layer-group text-teal-400 text-2xl"></i>
                                <span class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-teal-400 to-teal-200">
                                    PUZZLE NEXUS
                                </span>
                            </div>
                            <div class="flex items-center gap-4">
                                <button onclick="window.navTo('home')" class="text-gray-300 hover:text-white transition">
                                    <i class="fa-solid fa-home"></i>
                                </button>
                                <div class="h-6 w-px bg-gray-700"></div>
                                <div class="flex items-center gap-2">
                                    <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                                    <span class="text-xs text-gray-400 font-mono">${window.AppState.userId ? window.AppState.userId.substr(0,6) : '...'}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </nav>
            `;
        }

        function renderHome() {
            return `
                <div class="max-w-7xl mx-auto px-4 py-12 w-full animate-fade-in">
                    <div class="text-center mb-12">
                        <h1 class="text-5xl font-extrabold text-white mb-4 tracking-tight">
                            Master the <span class="text-teal-400">Grid</span>
                        </h1>
                        <p class="text-gray-400 text-lg max-w-2xl mx-auto">
                            Challenge your logic and memory. Play solo to train or create a room to compete in real-time cross-device battles.
                        </p>
                    </div>

                    <div class="grid md:grid-cols-2 gap-8 max-w-4xl mx-auto">
                        <!-- Multiplayer Card -->
                        <div class="group relative bg-gradient-to-br from-gray-800 to-gray-900 p-8 rounded-2xl border border-gray-700 hover:border-gold-400 transition-all duration-300 shadow-xl overflow-hidden">
                            <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition">
                                <i class="fa-solid fa-users text-9xl text-gold-400"></i>
                            </div>
                            <h2 class="text-3xl font-bold text-white mb-2 flex items-center gap-3">
                                <i class="fa-solid fa-globe text-gold-400"></i> Multiplayer
                            </h2>
                            <p class="text-gray-400 mb-8">Create a lobby and invite friends. Compete on the same puzzle seed.</p>
                            
                            <div class="space-y-3 relative z-10">
                                <button onclick="window.createRoom('public')" class="w-full py-3 bg-gold-600 hover:bg-gold-700 text-gray-900 font-bold rounded-lg transition transform active:scale-95 shadow-lg shadow-gold-500/20">
                                    Create Room
                                </button>
                                <div class="flex gap-2">
                                    <input id="room-code-input" type="text" placeholder="CODE" maxlength="4" class="w-24 bg-gray-950 border border-gray-700 rounded-lg px-3 text-center font-mono text-xl uppercase focus:border-gold-400 outline-none text-white">
                                    <button onclick="window.joinRoomInput()" class="flex-1 py-3 bg-gray-700 hover:bg-gray-600 border border-gray-600 text-white font-bold rounded-lg transition">
                                        Join Room
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Solo Card -->
                        <div class="group relative bg-gradient-to-br from-gray-800 to-gray-900 p-8 rounded-2xl border border-gray-700 hover:border-teal-400 transition-all duration-300 shadow-xl overflow-hidden">
                             <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition">
                                <i class="fa-solid fa-brain text-9xl text-teal-400"></i>
                            </div>
                            <h2 class="text-3xl font-bold text-white mb-2 flex items-center gap-3">
                                <i class="fa-solid fa-user-astronaut text-teal-400"></i> Solo Training
                            </h2>
                            <p class="text-gray-400 mb-8">Hone your skills. Select a challenge module.</p>
                            
                            <div class="grid grid-cols-1 gap-3 relative z-10">
                                <button onclick="window.startSoloGame(0)" class="py-3 px-4 bg-gray-700 hover:bg-teal-600/20 hover:text-teal-400 text-left rounded-lg transition flex items-center justify-between group-hover:border-teal-500/30 border border-transparent">
                                    <span>Sequential Memory</span> <i class="fa-solid fa-play opacity-0 group-hover:opacity-100 transition"></i>
                                </button>
                                <button onclick="window.startSoloGame(1)" class="py-3 px-4 bg-gray-700 hover:bg-teal-600/20 hover:text-teal-400 text-left rounded-lg transition flex items-center justify-between group-hover:border-teal-500/30 border border-transparent">
                                    <span>Light Switch Logic</span> <i class="fa-solid fa-lightbulb opacity-0 group-hover:opacity-100 transition"></i>
                                </button>
                                <button onclick="window.startSoloGame(2)" class="py-3 px-4 bg-gray-700 hover:bg-teal-600/20 hover:text-teal-400 text-left rounded-lg transition flex items-center justify-between group-hover:border-teal-500/30 border border-transparent">
                                    <span>Simon Pattern</span> <i class="fa-solid fa-music opacity-0 group-hover:opacity-100 transition"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderLobby() {
            const room = window.AppState.activeRoom;
            if (!room) return `<div class="p-10 text-center">Loading Room...</div>`;

            const isHost = room.hostId === window.AppState.userId;

            // Chat HTML
            const chatHtml = room.chat.map(msg => `
                <div class="mb-2 ${msg.uid === window.AppState.userId ? 'text-right' : 'text-left'}">
                    <span class="text-xs text-gray-500 block">${msg.sender}</span>
                    <span class="inline-block px-3 py-1 rounded-lg text-sm ${msg.uid === window.AppState.userId ? 'bg-teal-600 text-white' : 'bg-gray-700 text-gray-200'}">
                        ${msg.text}
                    </span>
                </div>
            `).join('');

            return `
                <div class="max-w-6xl mx-auto px-4 py-8 h-[calc(100vh-64px)] flex flex-col md:flex-row gap-6 animate-fade-in">
                    
                    <!-- Sidebar: Players & Controls -->
                    <div class="w-full md:w-1/3 flex flex-col gap-6">
                        <div class="bg-gray-800 rounded-xl p-6 border border-teal-500/30 shadow-lg">
                            <div class="flex justify-between items-start mb-4">
                                <div>
                                    <h2 class="text-sm text-teal-400 font-bold uppercase tracking-wider">Room Code</h2>
                                    <p class="text-4xl font-mono font-extrabold text-white tracking-widest cursor-pointer hover:text-gold-400 transition" onclick="window.copyCode('${room.roomCode}')" title="Click to Copy">${room.roomCode}</p>
                                </div>
                                <button onclick="window.leaveRoom()" class="text-red-400 hover:bg-red-900/30 p-2 rounded transition"><i class="fa-solid fa-sign-out-alt"></i></button>
                            </div>
                            
                            <h3 class="font-bold text-gray-400 mb-3 text-sm uppercase">Players</h3>
                            <div class="space-y-2 mb-6">
                                ${room.players.map(p => `
                                    <div class="flex items-center justify-between p-3 rounded bg-gray-700/50 border border-gray-700 ${p.id === window.AppState.userId ? 'border-teal-500/50' : ''}">
                                        <div class="flex items-center gap-3">
                                            <div class="w-8 h-8 rounded-full bg-gradient-to-br from-gray-600 to-gray-700 flex items-center justify-center text-xs font-bold">
                                                ${p.name.slice(-2)}
                                            </div>
                                            <span class="${p.id === window.AppState.userId ? 'text-teal-400 font-bold' : 'text-gray-300'}">${p.name}</span>
                                            ${p.id === room.hostId ? '<i class="fa-solid fa-crown text-gold-400 text-xs"></i>' : ''}
                                        </div>
                                        <span class="font-mono font-bold text-white">${p.score} pts</span>
                                    </div>
                                `).join('')}
                            </div>

                            ${isHost ? `
                                <div class="space-y-2">
                                    <p class="text-xs text-gray-400 mb-1">Select Game to Start:</p>
                                    <div class="grid grid-cols-3 gap-2 mb-2">
                                        <button onclick="window.selectLobbyGame(0)" class="p-2 rounded border border-gray-600 hover:bg-gray-700 text-xs text-center transition ${window.AppState.selectedGameId === 0 ? 'bg-teal-600 border-teal-400' : ''}">Memory</button>
                                        <button onclick="window.selectLobbyGame(1)" class="p-2 rounded border border-gray-600 hover:bg-gray-700 text-xs text-center transition ${window.AppState.selectedGameId === 1 ? 'bg-teal-600 border-teal-400' : ''}">Lights</button>
                                        <button onclick="window.selectLobbyGame(2)" class="p-2 rounded border border-gray-600 hover:bg-gray-700 text-xs text-center transition ${window.AppState.selectedGameId === 2 ? 'bg-teal-600 border-teal-400' : ''}">Simon</button>
                                    </div>
                                    <button onclick="window.startGameForRoom()" class="w-full py-3 bg-gradient-to-r from-teal-500 to-green-500 hover:from-teal-400 hover:to-green-400 text-white font-bold rounded-lg shadow-glow transition transform active:scale-95">
                                        START ROUND
                                    </button>
                                </div>
                            ` : `
                                <div class="text-center p-4 bg-gray-900/50 rounded border border-gray-700 border-dashed">
                                    <p class="text-sm text-gray-400 animate-pulse">Waiting for host to start...</p>
                                </div>
                            `}
                        </div>
                    </div>

                    <!-- Main Area: Chat or Game Board -->
                    <div class="flex-1 flex flex-col bg-gray-800 rounded-xl overflow-hidden shadow-2xl border border-gray-700">
                        ${room.status === 'playing' ? renderActiveGame(room) : `
                            <!-- Chat View -->
                            <div class="flex-1 p-4 overflow-y-auto space-y-2 bg-gray-900/30" id="chat-box">
                                ${chatHtml.length ? chatHtml : '<div class="h-full flex items-center justify-center text-gray-600">No messages yet. Say hi!</div>'}
                            </div>
                            <form onsubmit="window.submitChat(event)" class="p-4 bg-gray-800 border-t border-gray-700 flex gap-2">
                                <input id="chat-input" type="text" placeholder="Type a message..." class="flex-1 bg-gray-900 border border-gray-700 rounded-lg px-4 py-2 text-white focus:border-teal-500 outline-none">
                                <button type="submit" class="bg-teal-600 hover:bg-teal-700 px-6 py-2 rounded-lg text-white font-bold transition">Send</button>
                            </form>
                        `}
                    </div>
                </div>
            `;
        }

        function renderActiveGame(room) {
            // Depending on gameType, render the specific game board
            // room.gameType: 0 (Memory), 1 (Lights), 2 (Simon)
            const gameData = window.AppState.gameState;
            
            return `
                <div class="flex-1 flex flex-col relative">
                    <!-- Game HUD -->
                    <div class="h-16 bg-gray-900 border-b border-gray-700 flex items-center justify-between px-6">
                        <div class="font-bold text-xl text-white">${PUZZLE_NAMES[room.gameType]}</div>
                        <div class="flex gap-6">
                            <div class="text-center">
                                <span class="text-xs text-gray-500 uppercase">Mistakes</span>
                                <div class="text-xl font-mono text-red-400">${gameData.mistakes}</div>
                            </div>
                            <div class="text-center">
                                <span class="text-xs text-gray-500 uppercase">Score</span>
                                <div class="text-xl font-mono text-gold-400">${gameData.score}</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Game Area -->
                    <div class="flex-1 flex items-center justify-center p-4 bg-gray-900 relative overflow-hidden">
                         ${renderGameBoard(room.gameType)}
                    </div>
                    
                    ${room.gameType === 2 ? '' : `
                    <div class="h-1 bg-gray-800">
                        <div class="h-full bg-teal-500 transition-all duration-1000" style="width: ${gameData.status === 'memorize' ? '100%' : '0%'}"></div>
                    </div>`}
                </div>
            `;
        }

        function renderGameBoard(type) {
            const gd = window.AppState.gameState;
            
            // --- MEMORY MATRIX ---
            if (type == 0) {
                const size = gd.matrix ? Math.sqrt(gd.matrix.length) : 3; // Derive size or store it
                // Actually we stored gd.matrix as simple bool? No, sequence logic.
                // Re-deriving grid size from logic.
                const gridSize = gd.gridSize || 4;
                
                let cells = '';
                for(let r=0; r<gridSize; r++) {
                    for(let c=0; c<gridSize; c++) {
                        const pos = `${r}-${c}`;
                        const isTarget = gd.sequence.includes(pos);
                        const isSelected = gd.userSequence.includes(pos);
                        
                        let cellClass = "bg-gray-800 border-gray-700 hover:bg-gray-700 cursor-pointer";
                        let content = "";

                        if (gd.status === 'memorize') {
                            if (isTarget) cellClass = "bg-teal-500 border-teal-400 shadow-glow transform scale-105";
                        } else {
                            if (isSelected) {
                                cellClass = "bg-green-500 border-green-400";
                                content = '<i class="fa-solid fa-check text-white"></i>';
                            }
                        }

                        cells += `<div onclick="window.handleGameInput('${pos}')" class="grid-cell rounded-lg border-2 flex items-center justify-center text-xl transition-all duration-200 ${cellClass}">${content}</div>`;
                    }
                }
                
                return `
                    <div class="grid gap-3 animate-pop" style="grid-template-columns: repeat(${gridSize}, minmax(3rem, 5rem));">
                        ${cells}
                    </div>
                    ${gd.status === 'memorize' ? '<div class="absolute bottom-8 text-teal-400 font-bold animate-pulse text-xl tracking-widest">MEMORIZE PATTERN</div>' : ''}
                `;
            }

            // --- LIGHT SWITCH ---
            if (type == 1) {
                const gridSize = 5;
                let cells = '';
                if(gd.board) {
                    for(let r=0; r<gridSize; r++) {
                        for(let c=0; c<gridSize; c++) {
                            const isOn = gd.board[r][c];
                            const cellClass = isOn ? "bg-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.6)] border-yellow-200" : "bg-gray-800 border-gray-700 hover:bg-gray-700";
                            cells += `<div onclick="window.handleGameInput('${r}-${c}')" class="grid-cell rounded-md border-2 cursor-pointer transition-all duration-300 ${cellClass}"></div>`;
                        }
                    }
                }
                return `
                    <div class="grid gap-2 animate-pop" style="grid-template-columns: repeat(${gridSize}, minmax(2.5rem, 4rem));">
                        ${cells}
                    </div>
                    <div class="absolute bottom-8 text-gray-400 text-sm">Turn all lights OFF</div>
                `;
            }

            // --- SIMON ---
            if (type == 2) {
                const colors = ['bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-yellow-500'];
                const glowColors = ['shadow-[0_0_30px_red]', 'shadow-[0_0_30px_blue]', 'shadow-[0_0_30px_green]', 'shadow-[0_0_30px_yellow]'];
                
                let btns = '';
                for(let i=0; i<4; i++) {
                    const isActive = gd.activeLight === i;
                    const baseClass = colors[i];
                    const activeClass = isActive ? `brightness-150 scale-105 ${glowColors[i]} z-10` : 'opacity-70 hover:opacity-100';
                    
                    btns += `<div onclick="window.handleGameInput(${i})" class="w-24 h-24 sm:w-32 sm:h-32 rounded-2xl cursor-pointer transition-all duration-100 border-4 border-black/20 ${baseClass} ${activeClass}"></div>`;
                }

                return `
                    <div class="grid grid-cols-2 gap-4 animate-pop p-4 bg-gray-800/50 rounded-full border-4 border-gray-700">
                        ${btns}
                    </div>
                    <div class="absolute bottom-4 font-mono text-xl text-white">${gd.status === 'watch' ? 'WATCH' : 'REPEAT'}</div>
                `;
            }

            return `<div>Unknown Game</div>`;
        }

        // --- CORE APP RENDER ---
        window.renderApp = () => {
            const app = document.getElementById('app');
            app.innerHTML = renderHeader();

            const main = document.createElement('main');
            main.className = 'flex-grow flex flex-col';

            if (window.AppState.currentPage === 'home') {
                main.innerHTML = renderHome();
            } else if (window.AppState.currentPage === 'lobby') {
                main.innerHTML = renderLobby();
            }

            app.appendChild(main);

            // Auto-scroll chat
            const cb = document.getElementById('chat-box');
            if (cb) cb.scrollTop = cb.scrollHeight;
        };

        // --- INTERACTION HANDLERS ---

        window.createRoom = async (mode) => {
            try {
                const code = await Service.createRoom(mode);
                await window.joinRoom(code);
            } catch (e) { alert("Failed to create room: " + e.message); }
        };

        window.joinRoomInput = () => {
            const code = document.getElementById('room-code-input').value.toUpperCase();
            if(code.length === 4) window.joinRoom(code);
        };

        window.joinRoom = async (code) => {
            try {
                // Subscribe first to get updates instantly
                if(window.AppState.roomListener) window.AppState.roomListener(); // unsubscribe prev
                
                window.AppState.roomListener = Service.subscribeToRoom(code, (roomData) => {
                    if (!roomData) {
                        alert("Room closed or doesn't exist.");
                        window.navTo('home');
                        return;
                    }

                    // Sync logic
                    const prevStatus = window.AppState.activeRoom?.status;
                    const prevGameId = window.AppState.activeRoom?.gameSeed;

                    window.AppState.activeRoom = roomData;
                    
                    // Detect Game Start
                    if (roomData.status === 'playing' && (prevStatus !== 'playing' || prevGameId !== roomData.gameSeed)) {
                        initGameLocally(roomData.gameType, roomData.gameSeed);
                    }

                    if (window.AppState.currentPage !== 'lobby') window.navTo('lobby');
                    else renderApp();
                });

                // Add player to list
                await Service.joinRoom(code);

            } catch (e) {
                alert("Could not join room: " + e.message);
            }
        };

        window.leaveRoom = () => {
            if(window.AppState.roomListener) window.AppState.roomListener();
            window.AppState.activeRoom = null;
            window.AppState.roomListener = null;
            window.navTo('home');
        };

        window.copyCode = (code) => {
            navigator.clipboard.writeText(code);
            // Visual feedback could go here
        };

        window.submitChat = (e) => {
            e.preventDefault();
            const input = document.getElementById('chat-input');
            const msg = input.value.trim();
            if(msg && window.AppState.activeRoom) {
                Service.sendChat(window.AppState.activeRoom.roomCode, msg);
                input.value = '';
            }
        };

        window.selectLobbyGame = (id) => {
            window.AppState.selectedGameId = id;
            renderApp();
        };

        window.startGameForRoom = async () => {
            if (!window.AppState.activeRoom) return;
            const seed = Math.floor(Math.random() * 100000);
            await Service.setGameStatus(
                window.AppState.activeRoom.roomCode, 
                window.AppState.selectedGameId, 
                'playing', 
                seed
            );
        };

        window.startSoloGame = (id) => {
            // Create a fake room-like structure for solo play reuse
            window.AppState.activeRoom = {
                roomCode: 'SOLO',
                hostId: window.AppState.userId,
                players: [{ id: window.AppState.userId, name: 'You', score: 0 }],
                chat: [],
                status: 'playing',
                gameType: id,
                gameSeed: Date.now()
            };
            initGameLocally(id, Date.now());
            window.navTo('lobby');
        };

        // --- GAMEPLAY LOGIC ---

        function initGameLocally(type, seed) {
            let logic;
            if (type == 0) logic = initSequentialMemory(1, seed);
            else if (type == 1) logic = initLightSwitch(1, seed);
            else if (type == 2) logic = initSimon(1, seed);
            
            window.AppState.gameState = {
                ...logic,
                score: 0,
                mistakes: 0,
                level: 1,
                activeLight: -1 // For Simon animation
            };

            // Start Logic
            if (type == 0) runMemorySequence();
            if (type == 2) runSimonSequence();
        }

        function runMemorySequence() {
            window.AppState.gameState.status = 'memorize';
            renderApp();
            setTimeout(() => {
                window.AppState.gameState.status = 'input';
                renderApp();
            }, 2000 + (window.AppState.gameState.level * 200));
        }

        async function runSimonSequence() {
            window.AppState.gameState.status = 'watch';
            window.AppState.gameState.userStep = 0; // Reset user progress
            renderApp();
            
            await new Promise(r => setTimeout(r, 800));

            for (let i = 0; i < window.AppState.gameState.sequence.length; i++) {
                window.AppState.gameState.activeLight = window.AppState.gameState.sequence[i];
                renderApp();
                await new Promise(r => setTimeout(r, 600)); // Light ON time
                window.AppState.gameState.activeLight = -1;
                renderApp();
                await new Promise(r => setTimeout(r, 200)); // Gap
            }
            
            window.AppState.gameState.status = 'input';
            renderApp();
        }

        window.handleGameInput = (val) => {
            const gs = window.AppState.gameState;
            if (gs.status !== 'input' && gs.status !== 'playing') return;

            // Memory
            if (gs.type === 'memory') {
                if (gs.sequence.includes(val)) {
                    if (!gs.userSequence.includes(val)) {
                        gs.userSequence.push(val);
                        gs.score += 10;
                        if (gs.userSequence.length === gs.sequence.length) {
                            // Level Complete
                            handleLevelComplete();
                        } else {
                            renderApp();
                        }
                    }
                } else {
                    gs.mistakes++;
                    gs.score = Math.max(0, gs.score - 5);
                    renderApp();
                    // Feedback shake?
                }
            }

            // Light Switch
            else if (gs.type === 'lights') {
                const [r, c] = val.split('-').map(Number);
                toggleLights(gs.board, r, c, gs.gridSize);
                gs.score += 1; // points for moves? Usually fewer is better, but simpler here.
                
                // Check win
                const isClear = gs.board.every(row => row.every(cell => !cell));
                if (isClear) handleLevelComplete();
                else renderApp();
            }

            // Simon
            else if (gs.type === 'simon') {
                const expected = gs.sequence[gs.userStep];
                
                // Flash clicked button briefly
                gs.activeLight = val;
                renderApp();
                setTimeout(() => { gs.activeLight = -1; renderApp(); }, 200);

                if (val === expected) {
                    gs.userStep++;
                    if (gs.userStep >= gs.sequence.length) {
                        gs.score += 50;
                        handleLevelComplete();
                    }
                } else {
                    gs.mistakes++;
                    gs.score = Math.max(0, gs.score - 10);
                    // Reset or Game Over?
                    // Simple restart of sequence
                    runSimonSequence();
                }
            }
            
            // Sync Score
            if (window.AppState.activeRoom && window.AppState.activeRoom.roomCode !== 'SOLO') {
                Service.updateScore(window.AppState.activeRoom.roomCode, gs.score);
            }
        };

        function handleLevelComplete() {
            // Fireworks or visual flair
            confettiEffect();
            
            // Increment Level
            const gs = window.AppState.gameState;
            gs.level++;
            
            // Generate next level logic
            const seed = Date.now(); // or deterministic
            if (gs.type === 'memory') {
                const next = initSequentialMemory(gs.level, seed);
                gs.sequence = next.sequence;
                gs.gridSize = next.gridSize;
                gs.userSequence = [];
                runMemorySequence();
            } else if (gs.type === 'lights') {
                const next = initLightSwitch(gs.level, seed);
                gs.board = next.board;
                renderApp();
            } else if (gs.type === 'simon') {
                const next = initSimon(gs.level, seed);
                gs.sequence = next.sequence;
                runSimonSequence();
            }
        }

        // --- VISUAL EFFECTS ---
        function confettiEffect() {
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const particles = [];
            for(let i=0; i<100; i++) {
                particles.push({
                    x: window.innerWidth/2,
                    y: window.innerHeight/2,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 1.0,
                    color: `hsl(${Math.random()*360}, 100%, 50%)`
                });
            }
            
            function animate() {
                ctx.clearRect(0,0,canvas.width,canvas.height);
                let alive = false;
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.5; // gravity
                    p.life -= 0.02;
                    if(p.life > 0) {
                        alive = true;
                        ctx.globalAlpha = p.life;
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
                        ctx.fill();
                    }
                });
                if(alive) requestAnimationFrame(animate);
                else ctx.clearRect(0,0,canvas.width,canvas.height);
            }
            animate();
        }

    </script>
</body>
</html>
