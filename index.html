<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Nexus: Advanced Multiplayer Challenge</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Font Awesome for game icons and UI -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Press+Start+2P&display=swap');
        
        /* Custom Styles for the Advanced Game */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1f2937, #111827);
            min-height: 100vh;
            color: #ffffff;
        }
        .text-gold-400 { color: #FFD700; }
        .bg-gold-600 { background-color: #FFC72C; }
        .hover\:bg-gold-700:hover { background-color: #FFB300; }
        
        /* Game Grid Styling */
        #game-board {
            display: grid;
            /* 6x6 Grid for a challenging game */
            grid-template-columns: repeat(6, 1fr); 
            gap: 0.5rem;
            width: min(95vw, 600px);
            margin: 0 auto;
        }

        /* Card Styling */
        .card-container {
            position: relative;
            aspect-ratio: 1 / 1;
            perspective: 1000px;
        }

        .card {
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            cursor: pointer;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -2px rgba(0, 0, 0, 0.4);
        }

        .flipped .card {
            transform: rotateY(180deg);
        }

        .card-face, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            color: white;
            padding: 0.5rem;
        }

        .card-face {
            background-color: #2563eb; /* Blue for front */
            transform: rotateY(180deg);
        }

        .card-back {
            background: linear-gradient(45deg, #FFD700, #FFB300); /* Gold for back */
            border: 3px solid #fcd34d;
        }

        .matched .card-face {
            background-color: #10b981; /* Green for matched */
            color: #1f2937;
        }

        .current-turn-glow {
            box-shadow: 0 0 15px 5px #FFD700, 0 0 10px 2px rgba(255, 255, 255, 0.5);
            animation: pulse-glow 2s infinite alternate;
        }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 10px 2px #FFD700; }
            100% { box-shadow: 0 0 20px 7px #FFD700; }
        }

        /* Message Box Styling */
        #message-box {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 300px;
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div id="app" class="flex flex-col min-h-[90vh]">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl sm:text-5xl font-extrabold text-gold-400">
                <i class="fa-solid fa-brain mr-2"></i>Memory Nexus
            </h1>
            <p class="text-gray-400 mt-1">Advanced Multiplayer Card Matching Challenge</p>
        </header>

        <!-- Main Content Area (Rendered by JS) -->
        <main id="content" class="flex-grow flex flex-col justify-center items-center"></main>
        
        <!-- Modal for General Messages -->
        <div id="message-box"></div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, orderBy, limit, serverTimestamp, runTransaction, arrayUnion, setLogLevel, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase and App Constants
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyB-3kAk-lMT3jTny2YIs2R1_0mG-tJlmJI",
            authDomain: "puzzlesapp.firebaseapp.com",
            projectId: "puzzlesapp",
            storageBucket: "puzzlesapp.firebasestorage.app",
            messagingSenderId: "303461259730",
            appId: "1:303461259730:web:a1790a976b6d58d71dd00b",
            measurementId: "G-8YEJEBX0NE"
        };
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : FIREBASE_CONFIG;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        setLogLevel('Debug'); // Enable debug logging for Firestore

        // --- GLOBAL APP STATE ---
        let userId = null;
        let isAuthReady = false;
        let unsubscribeRoom = null;
        let lastPlayerCount = 0;
        
        const AppState = {
            view: 'HUB', // 'HUB', 'GAME'
            currentRoom: null, // Stores the full room object
            memoryCards: [], // Local state of the card grid
            // Game State
            flippedCards: [], // Holds indices of the currently flipped cards (max 2)
            isProcessingTurn: false, // Flag to prevent rapid clicking while cards are visible
        };

        // --- ADVANCED GAME CONFIG ---
        const GRID_SIZE = 6; // 6x6 grid
        const CARD_COUNT = GRID_SIZE * GRID_SIZE; // 36 cards
        const MAX_AP_PER_TURN = 2;
        const MISMATCH_VISIBILITY_TIME = 1500; // 1.5 seconds visibility
        const SPECIAL_CARD_SYMBOL = '‚ö°Ô∏è';
        const SPECIAL_CARD_TRIGGER_ID = 'special_shuffle_trigger';

        // --- UTILITY FUNCTIONS ---

        /**
         * Generates a 4-character uppercase room code.
         * @returns {string}
         */
        const generateRoomCode = () => {
            return Math.random().toString(36).substring(2, 6).toUpperCase();
        };

        /**
         * Displays a temporary floating message.
         * @param {string} message 
         * @param {string} title 
         */
        const showMessage = (message, title = 'Notification', duration = 3000) => {
            const messageBox = document.getElementById('message-box');
            const id = 'msg-' + Date.now();
            const element = document.createElement('div');
            element.id = id;
            element.className = 'bg-gray-800 text-white p-4 rounded-lg shadow-xl mb-3 transform transition duration-500 opacity-0 translate-x-full';
            element.innerHTML = `<p class="font-bold text-sm">${title}</p><p class="text-xs text-gray-300 mt-1">${message}</p>`;
            
            messageBox.appendChild(element);

            // Animate in
            setTimeout(() => {
                element.classList.remove('opacity-0', 'translate-x-full');
                element.classList.add('opacity-100', 'translate-x-0');
            }, 50); 

            // Animate out and remove
            setTimeout(() => {
                element.classList.remove('opacity-100', 'translate-x-0');
                element.classList.add('opacity-0', 'translate-x-full');
                setTimeout(() => {
                    if (messageBox.contains(element)) {
                        messageBox.removeChild(element);
                    }
                }, 500);
            }, duration);
        };

        /**
         * Shuffles an array (Fisher-Yates algorithm).
         * @param {Array} array 
         * @returns {Array}
         */
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };
        
        // --- GAME LOGIC & CARD GENERATION ---

        /**
         * Generates the initial, complex set of cards for the 6x6 grid.
         * Includes a special action card.
         * @returns {Array<Object>}
         */
        const generateCards = () => {
            const symbols = [
                'üöÄ', 'üí°', 'üî•', 'üíé', 'üîë', 'üåç', 'üåå', 'üí∞',
                'üõ°Ô∏è', '‚öôÔ∏è', 'üîÆ', 'ü¶†', 'üß±', 'üå≤', 'üîî', 'üåô',
                '‚è≥', '‚öñÔ∏è'
            ];
            
            // Need 18 pairs for 36 cards.
            // 17 regular pairs (34 cards) + 2 special cards (1 pair) = 36 cards.
            const cardValues = symbols.slice(0, 17)
                .flatMap(s => [s, s]); // 34 cards (17 pairs)
            
            // Add the special card pair
            cardValues.push(SPECIAL_CARD_SYMBOL, SPECIAL_CARD_SYMBOL); // 36 cards (18 pairs total)

            const shuffledValues = shuffleArray(cardValues);

            return shuffledValues.map((value, index) => ({
                id: index,
                value: value,
                isFlipped: false,
                isMatched: false,
                // Assign a unique type for the special card to handle its logic
                type: value === SPECIAL_CARD_SYMBOL ? SPECIAL_CARD_TRIGGER_ID : 'regular',
                matchedBy: null,
            }));
        };

        /**
         * Calculates the new Action Points for a player after a turn.
         * @param {Object} playerState The player's current state.
         * @param {boolean} isMatch Whether the last move was a successful match.
         * @returns {number} The new AP value.
         */
        const calculateNewAP = (playerState, isMatch) => {
            // Start with current AP - 1 (for flipping the second card)
            let newAP = playerState.actionPoints - 1;
            
            // Bonus AP for a match
            if (isMatch) {
                newAP += 2; // +1 to offset the cost, +1 for the match bonus
            }

            // Cap AP at MAX_AP_PER_TURN at the start of the next turn cycle
            return Math.min(newAP, MAX_AP_PER_TURN);
        };
        
        // --- FIREBASE SERVICE ---

        const MultiplayerService = {
            getRoomRef: (roomCode) => doc(db, `/artifacts/${appId}/public/data/rooms`, roomCode),
            
            /**
             * Attempts to create a new room.
             * @returns {Promise<string>} The new room code.
             */
            createRoom: async () => {
                const roomCode = generateRoomCode();
                const cards = generateCards();
                
                const newRoom = {
                    roomCode: roomCode,
                    createdAt: serverTimestamp(),
                    status: 'LOBBY', // LOBBY, IN_GAME, FINISHED
                    hostId: userId,
                    players: { 
                        [userId]: { id: userId, score: 0, actionPoints: MAX_AP_PER_TURN, turnOrder: 0, lastActivity: serverTimestamp(), frozenUntil: 0 }
                    },
                    currentTurn: userId,
                    board: JSON.stringify(cards), // Store board as JSON string
                    flippedCards: [], // [cardIndex1, cardIndex2]
                    lastFlipTime: 0,
                    chat: [],
                };

                try {
                    await setDoc(MultiplayerService.getRoomRef(roomCode), newRoom);
                    return roomCode;
                } catch (error) {
                    console.error("Error creating room:", error);
                    showMessage("Failed to create room.", '‚ùå Error');
                    throw error;
                }
            },

            /**
             * Updates the room state in the database using a transaction for safety.
             * @param {string} roomCode 
             * @param {function(Object): Object} updateFn 
             */
            updateRoomTransaction: async (roomCode, updateFn) => {
                const roomRef = MultiplayerService.getRoomRef(roomCode);
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomDoc = await transaction.get(roomRef);
                        if (!roomDoc.exists()) {
                            throw "Room does not exist!";
                        }
                        const currentData = roomDoc.data();
                        const newData = updateFn(currentData);
                        transaction.update(roomRef, newData);
                    });
                } catch (e) {
                    console.error("Transaction failed: ", e);
                    showMessage(`Transaction failed: ${e.message || e}`, '‚ö†Ô∏è DB Error', 5000);
                    // Critical: if the error indicates a race condition, try to re-render the current state
                    if (e.message && e.message.includes("contention")) {
                         showMessage("Game state conflict detected. Re-syncing...", 'üîÑ Syncing');
                         // Force a full re-render on transaction failure
                         renderApp();
                    }
                }
            },
            
            /**
             * Joins an existing room.
             * @param {string} roomCode 
             */
            joinRoom: async (roomCode) => {
                const roomRef = MultiplayerService.getRoomRef(roomCode);
                
                await MultiplayerService.updateRoomTransaction(roomCode, (currentData) => {
                    if (!currentData) throw new Error("Room not found.");
                    
                    if (!currentData.players[userId]) {
                        const numPlayers = Object.keys(currentData.players).length;
                        currentData.players[userId] = {
                            id: userId,
                            score: 0,
                            actionPoints: MAX_AP_PER_TURN,
                            turnOrder: numPlayers,
                            lastActivity: serverTimestamp(),
                            frozenUntil: 0,
                        };
                        currentData.chat.push({
                            sender: 'SYSTEM',
                            message: `Player ${userId.substring(0, 4)} joined the room.`,
                            timestamp: serverTimestamp(),
                        });
                    }
                    return currentData;
                });
            },

            /**
             * Leaves the room and removes the player.
             * @param {string} roomCode 
             */
            leaveRoom: async (roomCode) => {
                if (unsubscribeRoom) { unsubscribeRoom(); unsubscribeRoom = null; }
                
                await MultiplayerService.updateRoomTransaction(roomCode, (currentData) => {
                    if (currentData.players[userId]) {
                        delete currentData.players[userId];
                        currentData.chat.push({
                            sender: 'SYSTEM',
                            message: `Player ${userId.substring(0, 4)} left the room.`,
                            timestamp: serverTimestamp(),
                        });

                        // If the leaving player was the host, assign a new host
                        if (currentData.hostId === userId) {
                            const remainingPlayers = Object.keys(currentData.players);
                            if (remainingPlayers.length > 0) {
                                currentData.hostId = remainingPlayers[0];
                            }
                        }
                        
                        // If the leaving player was the current turn, advance the turn
                        if (currentData.currentTurn === userId && Object.keys(currentData.players).length > 0) {
                            currentData.currentTurn = MultiplayerService.getNextPlayerId(currentData);
                        }
                    }
                    return currentData;
                });
            },
            
            /**
             * Gets the ID of the next player in the turn order.
             * @param {Object} roomData 
             * @returns {string} The next player ID.
             */
            getNextPlayerId: (roomData) => {
                const playerIds = Object.keys(roomData.players)
                    .sort((a, b) => roomData.players[a].turnOrder - roomData.players[b].turnOrder);
                
                const currentIndex = playerIds.indexOf(roomData.currentTurn);
                const nextIndex = (currentIndex + 1) % playerIds.length;
                return playerIds[nextIndex];
            },
            
            /**
             * Handles a card flip action, which is the core game move.
             * This function is run inside a transaction.
             * @param {number} cardIndex 
             */
            flipCard: async (cardIndex) => {
                const roomCode = AppState.currentRoom.roomCode;

                await MultiplayerService.updateRoomTransaction(roomCode, (roomData) => {
                    const cards = JSON.parse(roomData.board);
                    const playerState = roomData.players[userId];
                    
                    // 1. Pre-Check: Is it the player's turn, not processing, card not matched/flipped?
                    if (roomData.currentTurn !== userId) {
                        throw new Error("It's not your turn.");
                    }
                    if (roomData.flippedCards.length >= 2) {
                        throw new Error("Two cards are already flipped. Wait for the game to reset them.");
                    }
                    if (cards[cardIndex].isMatched || cards[cardIndex].isFlipped) {
                        throw new Error("Card already revealed or matched.");
                    }
                    if (playerState.actionPoints < 1) {
                         throw new Error("Not enough Action Points to flip a card.");
                    }

                    // 2. State Update: Flip the card and consume 1 AP
                    cards[cardIndex].isFlipped = true;
                    roomData.flippedCards.push(cardIndex);
                    playerState.actionPoints -= 1; // Consume 1 AP

                    roomData.board = JSON.stringify(cards);
                    
                    const newFlipped = roomData.flippedCards;

                    if (newFlipped.length === 2) {
                        // This is the second flip, check for match
                        const card1 = cards[newFlipped[0]];
                        const card2 = cards[newFlipped[1]];
                        
                        // 3. Match Check Logic
                        if (card1.value === card2.value) {
                            // MATCH FOUND!
                            card1.isMatched = true;
                            card2.isMatched = true;
                            card1.isFlipped = true; // Keep flipped and matched
                            card2.isFlipped = true; // Keep flipped and matched
                            card1.matchedBy = userId;
                            card2.matchedBy = userId;
                            
                            playerState.score += 1;
                            playerState.actionPoints = calculateNewAP(playerState, true); // Award bonus AP
                            
                            roomData.board = JSON.stringify(cards);
                            roomData.flippedCards = []; // Clear flipped cards immediately on match
                            roomData.lastFlipTime = serverTimestamp();

                            // Special Card Logic: If the match included the special card
                            if (card1.type === SPECIAL_CARD_TRIGGER_ID || card2.type === SPECIAL_CARD_TRIGGER_ID) {
                                // Apply the special effect: Shuffle the entire board and reset AP for one player
                                const { newBoard, shuffledPlayerId } = MultiplayerService.applySpecialEffect(roomData, userId);
                                roomData.board = JSON.stringify(newBoard);
                                roomData.chat.push({
                                    sender: 'SYSTEM',
                                    message: `‚ö°Ô∏è SPECIAL CARD ACTIVATED! Board shuffled! Player ${shuffledPlayerId.substring(0, 4)} had their AP frozen for 1 turn.`,
                                    timestamp: serverTimestamp(),
                                });
                            }
                            
                            // Check for Game Over (All cards matched)
                            const matchedCount = cards.filter(c => c.isMatched).length;
                            if (matchedCount === CARD_COUNT) {
                                roomData.status = 'FINISHED';
                                roomData.chat.push({
                                    sender: 'SYSTEM',
                                    message: `üèÜ GAME OVER! All pairs found. Calculating scores...`,
                                    timestamp: serverTimestamp(),
                                });
                            } else {
                                // Player gets to go again (turn remains the same)
                                roomData.chat.push({
                                    sender: 'SYSTEM',
                                    message: `MATCH! ${userId.substring(0, 4)} gets another turn and bonus AP!`,
                                    timestamp: serverTimestamp(),
                                });
                            }

                        } else {
                            // NO MATCH: Prepare for turn change and card flip back
                            roomData.lastFlipTime = serverTimestamp(); // Mark time for auto-flip
                            // Turn change is handled in the listener after the auto-flip
                        }
                    } else if (newFlipped.length === 1) {
                         // First flip is just a state update, turn remains the same
                    }
                    
                    return roomData;
                });
            },

            /**
             * Advanced Game Mechanic: Applies the special card effect.
             * @param {Object} roomData 
             * @param {string} triggerUserId The ID of the player who triggered the effect.
             */
            applySpecialEffect: (roomData, triggerUserId) => {
                // 1. Shuffle the board
                const currentCards = JSON.parse(roomData.board);
                const matchedCards = currentCards.filter(c => c.isMatched);
                const unmatchedCards = currentCards.filter(c => !c.isMatched);

                // Preserve the state of matched cards, only shuffle the unmatched ones
                const unmatchedValues = unmatchedCards.map(c => c.value);
                const shuffledValues = shuffleArray(unmatchedValues);

                const newUnmatchedCards = unmatchedCards.map((card, index) => ({
                    ...card,
                    value: shuffledValues[index], // Assign new value from shuffled list
                    isFlipped: false, // Ensure they are face-down after shuffle
                }));
                
                // Combine and re-index the full board (order doesn't matter for logic, only for display)
                const newBoard = shuffleArray([...matchedCards, ...newUnmatchedCards]).map((card, index) => ({
                    ...card,
                    id: index // Re-index everything
                }));
                
                // 2. Freeze a random opponent's AP for one turn
                const otherPlayerIds = Object.keys(roomData.players).filter(id => id !== triggerUserId);
                let shuffledPlayerId = triggerUserId; // Default to self if no other players
                
                if (otherPlayerIds.length > 0) {
                    shuffledPlayerId = otherPlayerIds[Math.floor(Math.random() * otherPlayerIds.length)];
                    roomData.players[shuffledPlayerId].frozenUntil = Date.now() + 60000; // Freeze for 60 seconds (enough for a couple of turns)
                    roomData.players[shuffledPlayerId].actionPoints = 0;
                }

                return { newBoard, shuffledPlayerId };
            },
            
            /**
             * Force-updates the board state (e.g., flipping cards back, changing turn).
             * @param {string} roomCode 
             */
            finalizeTurn: async (roomCode) => {
                 await MultiplayerService.updateRoomTransaction(roomCode, (roomData) => {
                    if (roomData.flippedCards.length === 2) {
                        const cards = JSON.parse(roomData.board);
                        const [idx1, idx2] = roomData.flippedCards;
                        
                        // Flip cards back (only unmatched ones)
                        if (!cards[idx1].isMatched) cards[idx1].isFlipped = false;
                        if (!cards[idx2].isMatched) cards[idx2].isFlipped = false;
                        
                        // Reset flipped state in room
                        roomData.flippedCards = [];
                        roomData.board = JSON.stringify(cards);
                        
                        // Change turn
                        const currentPlayerId = roomData.currentTurn;
                        const nextPlayerId = MultiplayerService.getNextPlayerId(roomData);
                        roomData.currentTurn = nextPlayerId;
                        
                        // Refill AP for the new player, considering freeze state
                        const nextPlayerState = roomData.players[nextPlayerId];
                        
                        if (Date.now() < nextPlayerState.frozenUntil) {
                            nextPlayerState.actionPoints = 0;
                            roomData.chat.push({
                                sender: 'SYSTEM',
                                message: `üßä Player ${nextPlayerId.substring(0, 4)} is FROZEN and loses their turn!`,
                                timestamp: serverTimestamp(),
                            });
                            // Immediately advance turn again if frozen
                            const nextNextPlayerId = MultiplayerService.getNextPlayerId(roomData);
                            roomData.currentTurn = nextNextPlayerId;
                            roomData.players[nextNextPlayerId].actionPoints = MAX_AP_PER_TURN;
                        } else {
                            nextPlayerState.actionPoints = MAX_AP_PER_TURN;
                            nextPlayerState.frozenUntil = 0; // Clear freeze if expired
                        }
                        
                        roomData.players[nextPlayerId] = nextPlayerState;
                        
                        roomData.chat.push({
                            sender: 'SYSTEM',
                            message: `Turn passes to ${roomData.currentTurn.substring(0, 4)}.`,
                            timestamp: serverTimestamp(),
                        });
                    }
                    return roomData;
                });
            },

            /**
             * Sends a chat message to the room.
             * @param {string} roomCode 
             * @param {string} message 
             */
            sendMessage: async (roomCode, message) => {
                const roomRef = MultiplayerService.getRoomRef(roomCode);
                const chatMessage = {
                    sender: userId,
                    message: message,
                    timestamp: serverTimestamp(),
                };
                try {
                    await updateDoc(roomRef, {
                        chat: arrayUnion(chatMessage)
                    });
                } catch (error) {
                    console.error("Error sending message:", error);
                }
            },
            
            /**
             * Sets up a real-time listener for the room state.
             * @param {string} roomCode 
             * @param {function(Object): void} callback 
             * @returns {function(): void} Unsubscribe function.
             */
            listenToRoom: (roomCode, callback) => {
                const roomRef = MultiplayerService.getRoomRef(roomCode);
                return onSnapshot(roomRef, (docSnapshot) => {
                    if (docSnapshot.exists()) {
                        const roomData = docSnapshot.data();
                        
                        // Critical: Handle the auto-flip and turn change after a mismatch
                        if (roomData.flippedCards.length === 2) {
                            // Check if enough time has passed since the second card was flipped (lastFlipTime)
                            // Firestore timestamps need to be converted to JS Date objects
                            const lastFlipMs = roomData.lastFlipTime?.toDate()?.getTime() || Date.now();
                            if (Date.now() - lastFlipMs > MISMATCH_VISIBILITY_TIME) {
                                // Time is up, force the turn finalization to flip cards back and change turn
                                if (!AppState.isProcessingTurn) { // Use a local lock to prevent multiple finalize calls
                                    AppState.isProcessingTurn = true;
                                    MultiplayerService.finalizeTurn(roomCode).finally(() => {
                                        AppState.isProcessingTurn = false;
                                    });
                                }
                            }
                        }
                        
                        callback(roomData);
                    } else {
                        // Room deleted or no longer exists
                        window.leaveRoom(true);
                    }
                }, (error) => {
                    console.error("Listener error:", error);
                    showMessage("Lost connection to the room.", '‚ö†Ô∏è Disconnected');
                    window.leaveRoom(true);
                });
            },
        };

        // --- RENDER LOGIC ---

        /**
         * Renders the entire application based on the current AppState.
         */
        const renderApp = () => {
            const content = document.getElementById('content');
            content.innerHTML = '';
            
            if (!isAuthReady) {
                content.innerHTML = renderLoadingScreen();
                return;
            }

            if (AppState.view === 'HUB' || !AppState.currentRoom) {
                content.innerHTML = renderHub();
            } else if (AppState.view === 'GAME' && AppState.currentRoom) {
                content.innerHTML = renderGameScreen(AppState.currentRoom);
                renderChat(AppState.currentRoom); // Render chat box
                // Re-sync local card state
                AppState.memoryCards = JSON.parse(AppState.currentRoom.board);
            }
        };

        /**
         * Renders the loading screen.
         */
        const renderLoadingScreen = () => `
            <div class="text-center p-8 bg-gray-700 rounded-xl shadow-2xl">
                <i class="fa-solid fa-sync fa-spin text-4xl text-gold-400"></i>
                <p class="mt-4 text-xl">Initializing Nexus...</p>
                <p class="text-gray-400 text-sm">Awaiting authentication and connection.</p>
            </div>
        `;
        
        /**
         * Renders the main Hub screen for creating/joining games.
         */
        const renderHub = () => `
            <div class="w-full max-w-md p-6 sm:p-8 bg-gray-800 rounded-xl shadow-2xl border border-gray-700">
                <h2 class="text-2xl font-bold mb-4 text-white">Join the Challenge</h2>
                <p class="text-sm text-gray-400 mb-6">Your User ID: <span class="font-mono text-xs text-gold-400 break-all">${userId}</span></p>

                <div class="mb-6">
                    <button onclick="window.createAndJoinRoom()" class="w-full py-3 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg transition duration-200 shadow-lg shadow-green-900/50">
                        <i class="fa-solid fa-plus mr-2"></i>Create New Advanced Game
                    </button>
                    <p class="text-xs text-gray-400 mt-2 text-center">6x6 Grid, Special Cards, Action Points Mode</p>
                </div>

                <div class="mb-4">
                    <label for="room-code-input" class="block text-sm font-medium text-gray-300 mb-2">Or Join an Existing Room (4-letter code)</label>
                    <div class="flex space-x-2">
                        <input type="text" id="room-code-input" maxlength="4" placeholder="ABCD" class="flex-grow p-3 text-lg font-mono text-center uppercase bg-gray-700 border border-gray-600 rounded-lg focus:ring-gold-400 focus:border-gold-400 transition duration-150" oninput="this.value = this.value.toUpperCase()">
                        <button onclick="window.handleJoinRoomClick()" class="py-3 px-4 bg-gold-600 hover:bg-gold-700 text-white font-semibold rounded-lg transition duration-200">
                            Join
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        /**
         * Renders the game board and controls.
         * @param {Object} roomData 
         */
        const renderGameScreen = (roomData) => {
            const cards = JSON.parse(roomData.board);
            const isMyTurn = roomData.currentTurn === userId;
            const myPlayer = roomData.players[userId];
            const gameStatus = roomData.status;

            let statusMessage = '';
            let statusColor = '';
            
            if (gameStatus === 'FINISHED') {
                const winner = determineWinner(roomData);
                statusMessage = `üèÜ GAME OVER! Winner: ${winner ? winner.id.substring(0, 4) : 'TIE'}`;
                statusColor = 'text-green-400';
            } else if (isMyTurn) {
                const isFrozen = Date.now() < myPlayer.frozenUntil;
                if (isFrozen) {
                     statusMessage = `üßä YOU ARE FROZEN! Turn skipped (AP: 0)`;
                     statusColor = 'text-red-400';
                } else {
                     statusMessage = `YOUR TURN! AP: ${myPlayer.actionPoints}`;
                     statusColor = 'text-gold-400 current-turn-glow';
                }
            } else {
                statusMessage = `Turn: ${roomData.currentTurn.substring(0, 4)}... (Watch closely!)`;
                statusColor = 'text-blue-400';
            }


            const cardElements = cards.map((card, index) => {
                const isFlippable = isMyTurn && !card.isMatched && !card.isFlipped && myPlayer.actionPoints > 0 && gameStatus === 'LOBBY'; // Only allow flips in LOBBY state for simplicity
                
                // Allow host to start the game
                const action = gameStatus === 'LOBBY' && roomData.hostId === userId 
                    ? `window.startGame('${roomData.roomCode}')` 
                    : `window.handleCardClick(${index})`;
                    
                const cardClass = card.isMatched ? 'matched' : (card.isFlipped ? 'flipped' : '');
                
                // Add a hover effect only if the card is flippable
                const hoverClass = isFlippable && roomData.flippedCards.length < 2 && !AppState.isProcessingTurn ? 'hover:scale-105 transition-transform duration-100' : 'cursor-default';

                return `
                    <div class="card-container">
                        <div class="card ${cardClass} ${hoverClass} ${isFlippable ? 'cursor-pointer' : 'opacity-80'}" onclick="${isFlippable ? action : ''}">
                            <div class="card-face">
                                ${card.value}
                                ${card.isMatched ? `<span class="absolute bottom-1 right-1 text-xs text-gray-800">P: ${card.matchedBy.substring(0, 4)}</span>` : ''}
                            </div>
                            <div class="card-back">
                                <i class="fa-solid fa-question text-xl"></i>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            const playerList = Object.values(roomData.players)
                .sort((a, b) => a.turnOrder - b.turnOrder)
                .map(p => `
                    <div class="flex justify-between items-center p-2 rounded-lg ${p.id === roomData.currentTurn ? 'bg-gold-900/30 border border-gold-400' : 'bg-gray-700'}">
                        <span class="font-bold ${p.id === userId ? 'text-gold-400' : 'text-white'}">
                            ${p.id === userId ? 'You' : p.id.substring(0, 4)} ${p.id === roomData.hostId ? '<i class="fa-solid fa-crown text-xs ml-1"></i>' : ''}
                        </span>
                        <div class="flex items-center space-x-3">
                            <span class="text-sm font-mono text-gray-300"><i class="fa-solid fa-star text-yellow-500 mr-1"></i>${p.score}</span>
                            <span class="text-sm font-mono ${p.actionPoints > 0 ? 'text-green-400' : 'text-red-400'}"><i class="fa-solid fa-bolt mr-1"></i>AP: ${p.actionPoints}</span>
                            ${Date.now() < p.frozenUntil ? '<span class="text-red-500 text-xs font-bold">FROZEN</span>' : ''}
                        </div>
                    </div>
                `).join('');

            return `
                <div class="w-full max-w-5xl mx-auto flex flex-col lg:flex-row space-y-6 lg:space-y-0 lg:space-x-6">
                    <!-- Left Column: Game State & Board -->
                    <div class="lg:w-3/4">
                        <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-2xl border border-gray-700">
                            <div class="flex justify-between items-center mb-4">
                                <h2 class="text-xl font-bold ${statusColor}">${statusMessage}</h2>
                                <div class="flex space-x-2">
                                    <button onclick="window.copyRoomCode('${roomData.roomCode}')" class="text-sm px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded-full text-gray-300">
                                        Room: <span class="font-mono text-gold-400">${roomData.roomCode}</span>
                                    </button>
                                    <button onclick="window.leaveRoom()" class="text-sm px-3 py-1 bg-red-600 hover:bg-red-700 rounded-full text-white">
                                        <i class="fa-solid fa-door-open"></i> Leave
                                    </button>
                                </div>
                            </div>
                            
                            ${gameStatus === 'LOBBY' && roomData.hostId === userId ? 
                                `
                                <div class="text-center my-6 p-4 border border-blue-500/50 rounded-lg bg-blue-900/20">
                                    <p class="text-blue-300 mb-2">Game is in LOBBY status. Waiting for players...</p>
                                    <button onclick="window.startGame('${roomData.roomCode}')" class="py-2 px-6 bg-gold-600 hover:bg-gold-700 text-white font-semibold rounded-lg transition duration-200">
                                        <i class="fa-solid fa-play mr-2"></i>Start Game (Host Only)
                                    </button>
                                </div>
                                ` 
                            : ''}
                            
                            ${gameStatus === 'FINISHED' ? renderEndGame(roomData) : `<div id="game-board" class="mt-4">${cardElements}</div>`}
                        </div>
                    </div>

                    <!-- Right Column: Players & Chat -->
                    <div class="lg:w-1/4 flex flex-col space-y-6">
                        <!-- Player List -->
                        <div class="bg-gray-800 p-4 rounded-xl shadow-2xl border border-gray-700">
                            <h3 class="text-xl font-bold mb-3 text-gold-400">Players (${Object.keys(roomData.players).length})</h3>
                            <div class="space-y-2">
                                ${playerList}
                            </div>
                        </div>

                        <!-- Chat Box -->
                        <div class="bg-gray-800 p-4 rounded-xl shadow-2xl border border-gray-700 flex-grow flex flex-col h-64 lg:h-full min-h-[300px]">
                            <h3 class="text-xl font-bold mb-3 text-gold-400">Chat</h3>
                            <div id="chat-messages" class="flex-grow overflow-y-auto space-y-2 mb-3 pr-2 text-sm">
                                <!-- Chat messages injected here -->
                            </div>
                            <form onsubmit="window.sendChat(event)" class="flex">
                                <input type="text" id="chat-input" placeholder="Say something..." class="flex-grow p-2 bg-gray-700 border border-gray-600 rounded-l-lg text-white text-sm focus:ring-gold-400 focus:border-gold-400" required>
                                <button type="submit" class="p-2 bg-blue-600 hover:bg-blue-700 rounded-r-lg text-white">
                                    <i class="fa-solid fa-paper-plane"></i>
                                </button>
                            </form>
                        </div>
                    </div>
                </div>
            `;
        };
        
        /**
         * Renders the end-game screen with results.
         * @param {Object} roomData 
         */
        const renderEndGame = (roomData) => {
            const results = Object.values(roomData.players)
                .sort((a, b) => b.score - a.score); // Sort by score descending
            
            const winner = determineWinner(roomData);
            
            const playerResults = results.map((p, index) => {
                const isWinner = winner && winner.id === p.id;
                const podiumClass = index === 0 ? 'bg-green-800/50' : (index === 1 ? 'bg-blue-800/50' : 'bg-gray-700/50');
                return `
                    <div class="flex justify-between items-center p-3 rounded-lg ${podiumClass}">
                        <span class="font-bold text-lg ${isWinner ? 'text-gold-400' : 'text-white'}">
                            ${isWinner ? 'ü•á ' : (index + 1) + '. '}${p.id === userId ? 'You' : p.id.substring(0, 4)}
                        </span>
                        <span class="text-xl font-extrabold text-gold-400">${p.score} <span class="text-sm text-gray-400">pairs</span></span>
                    </div>
                `;
            }).join('');
            
            return `
                <div class="text-center p-8 bg-gray-700 rounded-xl my-4">
                    <i class="fa-solid fa-trophy text-6xl text-gold-400 mb-4"></i>
                    <h2 class="text-4xl font-extrabold text-white mb-2">${winner ? winner.id === userId ? 'VICTORY!' : 'GAME OVER' : 'TIE!'}</h2>
                    <p class="text-gray-300 text-lg mb-6">${winner ? `Player ${winner.id.substring(0, 4)} won with ${winner.score} pairs.` : 'The game ended in a tie!'}</p>
                    
                    <div class="max-w-xs mx-auto space-y-2">
                        ${playerResults}
                    </div>
                    
                    <button onclick="window.leaveRoom()" class="mt-8 py-2 px-6 bg-gold-600 hover:bg-gold-700 text-white font-semibold rounded-lg transition duration-200">
                        Back to Hub
                    </button>
                </div>
            `;
        };
        
        /**
         * Determines the winner of the game.
         * @param {Object} roomData 
         * @returns {Object|null} The winner's player object, or null for a tie.
         */
        const determineWinner = (roomData) => {
             const players = Object.values(roomData.players);
             if (players.length === 0) return null;
             
             players.sort((a, b) => b.score - a.score);
             
             if (players.length > 1 && players[0].score === players[1].score) {
                 return null; // It's a tie
             }
             return players[0];
        };
        
        /**
         * Renders the chat messages.
         * @param {Object} roomData 
         */
        const renderChat = (roomData) => {
            const chatMessagesDiv = document.getElementById('chat-messages');
            if (!chatMessagesDiv) return;

            // Only render new messages to prevent flicker/re-scroll
            const currentMessages = Array.from(chatMessagesDiv.children).map(el => el.dataset.time);
            
            roomData.chat.forEach(msg => {
                const timestamp = msg.timestamp?.toDate()?.getTime() || Date.now();
                if (!currentMessages.includes(String(timestamp))) {
                    const isSystem = msg.sender === 'SYSTEM';
                    const isMe = msg.sender === userId;
                    const senderDisplay = isSystem ? 'System' : (isMe ? 'You' : msg.sender.substring(0, 4));
                    const senderColor = isSystem ? 'text-yellow-400 font-bold' : (isMe ? 'text-green-400' : 'text-blue-400');
                    const messageClass = isSystem ? 'italic text-gray-400' : 'text-white';

                    const msgElement = document.createElement('p');
                    msgElement.dataset.time = timestamp;
                    msgElement.className = 'break-words';
                    msgElement.innerHTML = `<span class="${senderColor} mr-1">${senderDisplay}:</span> <span class="${messageClass}">${msg.message}</span>`;
                    chatMessagesDiv.appendChild(msgElement);
                }
            });
            
            // Auto-scroll to the bottom
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
        };

        // --- WINDOW EXPOSED FUNCTIONS (UI INTERACTIONS) ---
        
        window.createAndJoinRoom = async () => {
            try {
                const roomCode = await MultiplayerService.createRoom();
                showMessage(`Room ${roomCode} created! Waiting for players.`, '‚úÖ Success');
                await window.joinRoom(roomCode);
            } catch (e) {
                console.error("Failed to create room:", e);
                showMessage('Could not create room. Try again.', '‚ùå Error');
            }
        };

        window.handleJoinRoomClick = async () => {
            const val = document.getElementById('room-code-input').value.toUpperCase();
            if(val.length === 4) await window.joinRoom(val);
        };

        window.joinRoom = async (roomCode) => {
            await window.leaveRoom(false); // Clean up any existing listeners/state first
            try {
                // Ensure room exists before joining (simple read check)
                const docSnap = await getDoc(MultiplayerService.getRoomRef(roomCode));
                if (!docSnap.exists()) {
                    showMessage(`Room code ${roomCode} not found.`, '‚ùå Error');
                    return;
                }
                
                await MultiplayerService.joinRoom(roomCode);
                
                // Set up the listener immediately after joining
                unsubscribeRoom = MultiplayerService.listenToRoom(roomCode, (roomData) => {
                    AppState.currentRoom = roomData;
                    AppState.view = 'GAME';
                    
                    // Check for player count changes (e.g., someone joined)
                    const currentPlayers = Object.keys(roomData.players).length;
                    if (currentPlayers > lastPlayerCount) {
                        showMessage(`Player ${Object.keys(roomData.players).pop().substring(0, 4)} joined!`, 'üîî New Player');
                    }
                    lastPlayerCount = currentPlayers;
                    
                    renderApp();
                });
                showMessage(`Joined room ${roomCode}.`, 'üéâ Success');

            } catch (error) {
                console.error("Error joining room:", error);
                showMessage(`Failed to join room ${roomCode}.`, '‚ùå Error');
                window.leaveRoom(true);
            }
        };

        window.leaveRoom = async (shouldRender = true) => {
            if (AppState.currentRoom) {
                 // Try to remove self from the room database
                try {
                    await MultiplayerService.leaveRoom(AppState.currentRoom.roomCode);
                } catch (e) {
                    console.error("Error gracefully leaving room:", e);
                    // Continue cleanup even if DB update fails
                }
            }
            
            if (unsubscribeRoom) { unsubscribeRoom(); unsubscribeRoom = null; }
            AppState.currentRoom = null;
            AppState.view = 'HUB';
            lastPlayerCount = 0;
            
            if (shouldRender) {
                renderApp();
                showMessage("You left the room.", 'üëã Disconnected');
            }
        };

        window.copyRoomCode = (code) => {
            // Using modern clipboard API for better experience
            if (navigator.clipboard) {
                 navigator.clipboard.writeText(code)
                    .then(() => showMessage('Room code copied to clipboard!', 'üìã Copied'))
                    .catch(err => {
                        console.error('Could not copy text: ', err);
                        // Fallback: Use execCommand for broader support (especially in iframe)
                        const tempInput = document.createElement('input');
                        document.body.appendChild(tempInput);
                        tempInput.value = code;
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);
                        showMessage('Room code copied to clipboard!', 'üìã Copied');
                    });
            } else {
                 // Fallback: Use execCommand
                 const tempInput = document.createElement('input');
                 document.body.appendChild(tempInput);
                 tempInput.value = code;
                 tempInput.select();
                 document.execCommand('copy');
                 document.body.removeChild(tempInput);
                 showMessage('Room code copied to clipboard!', 'üìã Copied');
            }
        };

        window.sendChat = async (e) => {
            e.preventDefault();
            const input = document.getElementById('chat-input');
            const msg = input.value;
            if(msg.trim() && AppState.currentRoom) {
                await MultiplayerService.sendMessage(AppState.currentRoom.roomCode, msg);
                input.value = '';
            }
        };
        
        window.startGame = async (roomCode) => {
            if (AppState.currentRoom.hostId !== userId) {
                showMessage("Only the host can start the game.", 'üö´ Unauthorized');
                return;
            }
            
             if (Object.keys(AppState.currentRoom.players).length < 2) {
                showMessage("Need at least 2 players to start a multiplayer game.", 'üë• Not Enough Players');
                return;
            }
            
            try {
                await updateDoc(MultiplayerService.getRoomRef(roomCode), {
                    status: 'IN_GAME',
                    chat: arrayUnion({
                        sender: 'SYSTEM',
                        message: `The game has started! Player ${AppState.currentRoom.currentTurn.substring(0, 4)} goes first.`,
                        timestamp: serverTimestamp(),
                    }),
                });
            } catch (error) {
                console.error("Error starting game:", error);
                showMessage("Failed to start game.", '‚ùå Error');
            }
        };
        
        window.handleCardClick = async (cardIndex) => {
            if (AppState.currentRoom.status !== 'IN_GAME') {
                 showMessage("The game has not started yet.", '‚úã Hold On');
                 return;
            }
            if (AppState.currentRoom.currentTurn !== userId) {
                showMessage("It's not your turn.", 'üö´ Wait');
                return;
            }
            if (AppState.isProcessingTurn || AppState.currentRoom.flippedCards.length >= 2) {
                // Ignore clicks if a match/mismatch is being processed
                return;
            }
            
            // Local lock for immediate UI feedback before transaction
            AppState.isProcessingTurn = true;
            try {
                await MultiplayerService.flipCard(cardIndex);
            } catch (e) {
                // If transaction failed, re-enable clicks and show error
                showMessage(e.message || "An error occurred during the flip.", '‚ö†Ô∏è Failed Move');
            } finally {
                // Unlock after API call completes (successful or failed)
                AppState.isProcessingTurn = false;
            }
        };

        // --- AUTHENTICATION & INITIALIZATION ---
        
        const initApp = async () => {
            try {
                // 1. Authenticate the user
                const auth = getAuth(app);
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                // 2. Set up Auth State Listener
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        console.log("Authenticated with UID:", userId);
                        
                        // 3. Initial Render
                        window.loadGame('HUB'); // Load the HUB view once authenticated
                    } else {
                        userId = null;
                        isAuthReady = true; // Still ready, just unauthenticated (shouldn't happen with the token/anon flow)
                        console.log("Authentication failed or logged out.");
                        renderApp();
                    }
                });

            } catch (error) {
                console.error("Authentication failed during startup:", error);
                // Handle critical startup failure
                isAuthReady = true;
                renderApp();
            }
        };
        
        window.loadGame = (view) => {
            AppState.view = view;
            renderApp();
        };

        // --- STARTUP ---
        initApp();
    </script>
</body>
</html>
