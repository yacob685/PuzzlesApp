<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Nexus - Multiplayer Memory</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1f2937, #111827); /* Dark blue-grey gradient */
            min-height: 100vh;
        }
        .text-gold-400 { color: #FFD700; }
        .bg-gold-600 { background-color: #FFC72C; }
        .hover\:bg-gold-700:hover { background-color: #FFB300; }
        .shadow-gold-500\/50 { box-shadow: 0 10px 15px -3px rgba(255, 199, 44, 0.5), 0 4px 6px -4px rgba(255, 199, 44, 0.5); }
        
        .shadow-rainbow {
            box-shadow: 
                0 0 10px rgba(0, 255, 255, 0.4),
                0 0 20px rgba(255, 215, 0, 0.4),
                0 0 30px rgba(255, 0, 255, 0.4);
            transition: all 0.3s ease-in-out;
        }
        .card {
            background-color: #374151; /* Darker card background */
            transition: transform 0.3s ease, background-color 0.3s ease;
            transform-style: preserve-3d;
            position: relative;
        }
        .card-inner {
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            color: #1f2937;
        }
        .card-back {
            background-color: #6b7280; /* Grey back */
            border: 4px solid #4b5563;
        }
        .card-front {
            background-color: #f3f4f6; /* Light front */
            transform: rotateY(180deg);
        }
        .card.matched .card-front, .card.matched .card-back {
            background-color: #10b981; /* Green matched */
            border-color: #059669;
            color: white;
            opacity: 0.5;
            pointer-events: none;
        }

        /* Responsive Grid */
        #game-board {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(4, 1fr);
            max-width: 600px;
            margin: 0 auto;
        }

        /* Mobile specific adjustments */
        @media (max-width: 640px) {
            #game-board {
                gap: 0.5rem;
                grid-template-columns: repeat(3, 1fr);
                max-width: 90vw;
            }
            .card {
                aspect-ratio: 1 / 1;
            }
            .card-face {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div id="app" class="max-w-7xl mx-auto">
        
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl sm:text-5xl font-extrabold text-white mb-2 shadow-rainbow inline-block p-2 rounded-lg">Puzzle Nexus</h1>
            <p class="text-xl text-gray-400">Multiplayer Memory Game</p>
            <div id="user-info" class="mt-2 text-sm text-gray-500"></div>
        </header>

        <!-- Message Box -->
        <div id="message-box" class="fixed top-0 left-0 right-0 p-4 bg-yellow-500 text-gray-900 text-center font-semibold transition-all duration-300 transform -translate-y-full z-50 rounded-b-lg">
            <span id="message-title" class="font-bold mr-2"></span><span id="message-text"></span>
        </div>

        <!-- Main Content Area -->
        <div id="main-content" class="bg-gray-800 p-6 rounded-xl shadow-2xl transition-all duration-500">
            
            <!-- Room Selector/Info Area (Rendered by JS) -->
            <div id="room-area">
                <!-- Content will be injected here by renderApp() -->
            </div>

            <!-- Game and Chat Area (Rendered by JS when connected) -->
            <div id="game-container" class="mt-6 hidden md:grid md:grid-cols-3 md:gap-6">
                <div class="md:col-span-2">
                    <h2 class="text-2xl font-bold text-white mb-4">Game Board</h2>
                    <div id="game-board-wrapper" class="p-4 bg-gray-700 rounded-lg shadow-inner">
                        <div id="game-board">
                            <!-- Cards will be injected here -->
                        </div>
                    </div>
                    <div id="game-status" class="mt-4 p-3 bg-gray-700 text-white rounded-lg text-center font-semibold">
                        Waiting for game to start...
                    </div>
                </div>
                
                <!-- Chat & Players Column -->
                <div class="md:col-span-1 flex flex-col space-y-4">
                    <!-- Players List -->
                    <div class="bg-gray-700 p-4 rounded-lg flex-shrink-0">
                        <h3 class="text-xl font-semibold text-white mb-3">Players <span id="player-count" class="text-gray-400"></span></h3>
                        <ul id="players-list" class="space-y-2 text-gray-300">
                            <!-- Player list injected here -->
                        </ul>
                    </div>

                    <!-- Chat Box -->
                    <div class="bg-gray-700 p-4 rounded-lg flex-grow flex flex-col">
                        <h3 class="text-xl font-semibold text-white mb-3">Chat</h3>
                        <div id="chat-log" class="flex-grow overflow-y-auto h-40 space-y-2 mb-4 p-2 bg-gray-600 rounded-lg text-sm">
                            <!-- Chat messages injected here -->
                        </div>
                        <form onsubmit="window.sendChat(event)" class="flex">
                            <input id="chat-input" type="text" placeholder="Type a message..." class="flex-grow p-2 rounded-l-lg bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-gold-400">
                            <button type="submit" class="bg-gold-600 hover:bg-gold-700 text-gray-900 font-bold p-2 rounded-r-lg transition duration-150">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </form>
                    </div>
                </div>
            </div>

        </div>

        <!-- Room List Modal (Hidden by default) -->
        <div id="room-list-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 p-6 rounded-xl w-full max-w-md shadow-2xl">
                <h2 class="text-2xl font-bold text-white mb-4">Active Rooms</h2>
                <ul id="active-rooms-list" class="space-y-3 max-h-60 overflow-y-auto pr-2">
                    <!-- List of rooms injected here -->
                </ul>
                <button onclick="document.getElementById('room-list-modal').classList.add('hidden')" class="mt-6 w-full p-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg transition duration-150">
                    Close
                </button>
            </div>
        </div>

    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- FIREBASE INITIALIZATION AND AUTHENTICATION ---
        
        // Global variables provided by the Canvas environment
        
        // Check if the variables exist (they are defined by the Gemini environment)
        const isCanvasEnvironment = typeof __firebase_config !== 'undefined';

        let appId;
        let firebaseConfig;
        let initialAuthToken;

        if (isCanvasEnvironment) {
            // Use the variables provided by the Canvas environment
            appId = __app_id;
            firebaseConfig = JSON.parse(__firebase_config);
            initialAuthToken = __initial_auth_token;
        } else {
            // --- FALLBACK FOR STANDALONE / PUBLISHED VERSION ---
            // If running outside the Gemini environment, Firebase will fail to initialize.
            // We set placeholders and handle the error gracefully in initApp().
            // For Firebase JS SDK v7.20.0 and later, measurementId is optional
            firebaseConfig = {
              apiKey: "AIzaSyB-3kAk-lMT3jTny2YIs2R1_0mG-tJlmJI",
              authDomain: "puzzlesapp.firebaseapp.com",
              projectId: "puzzlesapp",
              storageBucket: "puzzlesapp.firebasestorage.app",
              messagingSenderId: "303461259730",
              appId: "1:303461259730:web:a1790a976b6d58d71dd00b",
              measurementId: "G-8YEJEBX0NE"
            };
            appId = firebaseConfig.projectId; // Use project ID as app ID for fallback collection path
            initialAuthToken = null;
        }

        let app;
        let db;
        let auth;
        let userId = null;
        let unsubscribeRoom = null;
        let unsubscribeRooms = null;
        
        const showMessage = (text, title = 'Notification', duration = 3000) => {
            const box = document.getElementById('message-box');
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            
            box.classList.remove('-translate-y-full');
            box.classList.add('translate-y-0');
            
            setTimeout(() => {
                box.classList.remove('translate-y-0');
                box.classList.add('-translate-y-full');
            }, duration);
        };

        const initApp = async () => {
             if (!firebaseConfig) {
                // This is the error handler for external publishing
                showMessage('Multiplayer disabled. Missing Firebase configuration.', 'ðŸ”´ Fatal Error');
                document.getElementById('room-area').innerHTML = `
                    <div class="p-6 bg-red-800 text-white rounded-lg">
                        <h2 class="font-bold text-xl mb-2">Multiplayer Disabled (External Use)</h2>
                        <p>This application relies on a secured Firebase/Firestore connection that is automatically provided in the Gemini environment.</p>
                        <p class="mt-2">To run this version outside the environment, you must:</p>
                        <ol class="list-decimal list-inside mt-2 ml-4">
                            <li>Create your own Firebase project and Firestore database.</li>
                            <li>Get your project's configuration object.</li>
                            <li>Insert your config object in the <code>&lt;script&gt;</code> block where the <code>firebaseConfig = null;</code> fallback is currently located.</li>
                            <li>Use your own secure authentication method.</li>
                        </ol>
                        <p class="mt-3 font-semibold">Current environment does not provide the configuration automatically.</p>
                    </div>
                `;
                return;
            }

            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            setLogLevel('Debug'); // Enable logging for debugging

            try {
                // Handle authentication
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                
                userId = auth.currentUser?.uid;
                if (userId) {
                    document.getElementById('user-info').textContent = `User ID: ${userId}`;
                    console.log("Authenticated successfully. User ID:", userId);
                    
                    // Start listening to the list of active rooms immediately
                    MultiplayerService.listenToActiveRooms((rooms) => { 
                        AppState.activeRooms = rooms; 
                        renderApp(); 
                    });
                    renderApp(); // Initial render after auth
                } else {
                    throw new Error("User ID is null after sign-in.");
                }

            } catch (error) {
                console.error("Authentication failed:", error);
                showMessage('Authentication failed. Multiplayer disabled.', 'âŒ Auth Error');
            }
        };
        
        // --- GAME STATE AND HELPERS ---

        const CARD_ICONS = ['ðŸŽ', 'ðŸŒ', 'ðŸ’', 'ðŸ‡', 'ðŸ‹', 'ðŸ¥', 'ðŸ‰', 'ðŸ', 'ðŸ“'];
        const CARD_COUNT = 18; // 9 pairs
        const ROOM_COLLECTION = `artifacts/${appId}/public/data/memoryRooms`;

        const AppState = {
            currentRoom: null,
            activeRooms: [],
            gameBoard: [],
            players: {},
            currentPlayer: null,
            isMyTurn: false,
            waitingForPair: false,
            currentFlippedCards: [],
        };
        
        let lastPlayerCount = 0; // Used for change detection in onSnapshot

        const getPlayerColor = (id) => {
            const colors = ['text-blue-400', 'text-red-400', 'text-green-400', 'text-yellow-400', 'text-purple-400', 'text-pink-400'];
            // Simple hash function to assign color based on UID
            let hash = 0;
            for (let i = 0; i < id.length; i++) {
                hash = id.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        };

        const generateBoard = () => {
            let icons = [...CARD_ICONS].slice(0, CARD_COUNT / 2);
            icons = icons.flatMap(icon => [icon, icon]);
            
            // Fisher-Yates shuffle
            for (let i = icons.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [icons[i], icons[j]] = [icons[j], icons[i]];
            }

            return icons.map((icon, index) => ({
                id: index,
                icon: icon,
                isFlipped: false,
                isMatched: false,
            }));
        };


        // --- FIREBASE SERVICE IMPLEMENTATION ---

        const MultiplayerService = {
            async getActiveRooms() {
                if (!db) return [];
                try {
                    const q = query(collection(db, ROOM_COLLECTION));
                    const snapshot = await getDocs(q);
                    return snapshot.docs.map(doc => ({ roomCode: doc.id, ...doc.data() }));
                } catch (e) {
                    console.error("Error getting active rooms: ", e);
                    return [];
                }
            },

            async createRoom() {
                if (!db || !userId) throw new Error("Database or User ID not initialized.");
                const roomCode = Math.random().toString(36).substring(2, 6).toUpperCase();
                const board = generateBoard();
                
                const roomData = {
                    status: 'waiting', // waiting, playing, finished
                    currentPlayerId: userId,
                    players: [{ id: userId, score: 0, color: getPlayerColor(userId) }],
                    board: JSON.stringify(board), // Serialize board
                    chat: [{ sender: 'SYSTEM', message: `${userId} created the room.`, timestamp: Date.now() }],
                    flippedCards: [],
                    matchRequests: [], // For handling concurrent flips
                    createdAt: Date.now(),
                };
                
                const roomRef = doc(db, ROOM_COLLECTION, roomCode);
                await setDoc(roomRef, roomData);
                return { roomCode, ...roomData };
            },

            async joinRoom(roomCode) {
                if (!db || !userId) throw new Error("Database or User ID not initialized.");
                const roomRef = doc(db, ROOM_COLLECTION, roomCode);

                const roomSnap = await getDoc(roomRef);
                if (!roomSnap.exists()) {
                     throw new Error(`Room ${roomCode} does not exist.`);
                }
                const roomData = roomSnap.data();
                
                // Only add player if they are not already in the list
                const isAlreadyJoined = roomData.players.some(p => p.id === userId);
                if (!isAlreadyJoined) {
                    await updateDoc(roomRef, {
                        players: [...(roomData.players || []), { id: userId, score: 0, color: getPlayerColor(userId) }]
                    });
                    await this.sendMessage(roomCode, `${userId} joined the room.`, 'SYSTEM');
                }
            },

            async getRoom(roomCode) {
                if (!db) return null;
                const roomRef = doc(db, ROOM_COLLECTION, roomCode);
                const docSnap = await getDoc(roomRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Deserialize board
                    try {
                       data.board = JSON.parse(data.board);
                    } catch (e) {
                       console.error("Failed to parse board data:", e);
                       data.board = [];
                    }
                    return { roomCode: docSnap.id, ...data };
                }
                return null;
            },

            async flipCard(roomCode, cardIndex) {
                if (!db || !userId) throw new Error("Database or User ID not initialized.");
                const roomRef = doc(db, ROOM_COLLECTION, roomCode);

                // Add a flip request to the queue
                await updateDoc(roomRef, {
                    matchRequests: [
                        ...(AppState.currentRoom?.matchRequests || []),
                        { playerId: userId, cardIndex: cardIndex, timestamp: Date.now() }
                    ]
                });
            },

            async sendMessage(roomCode, message, sender = userId) {
                if (!db) return;
                const roomRef = doc(db, ROOM_COLLECTION, roomCode);
                await updateDoc(roomRef, {
                    chat: [...(AppState.currentRoom?.chat || []), { sender, message, timestamp: Date.now() }]
                });
            },
            
            // This is crucial: handles the real-time updates for a single room
            listenToRoom(roomCode, callback) {
                if (!db) return () => {};
                const roomRef = doc(db, ROOM_COLLECTION, roomCode);
                // Clear existing listener if any
                if (unsubscribeRoom) { unsubscribeRoom(); unsubscribeRoom = null; } 
                
                unsubscribeRoom = onSnapshot(roomRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        // Deserialize board before passing to callback
                        try {
                           data.board = JSON.parse(data.board);
                        } catch (e) {
                           console.error("Failed to parse board data:", e);
                           data.board = [];
                        }
                        callback({ roomCode: docSnap.id, ...data });
                    } else {
                        callback(null);
                        showMessage("Room was deleted or closed.", "âŒ Disconnected");
                        window.leaveRoom();
                    }
                }, (error) => {
                    console.error("Error listening to room: ", error);
                    showMessage("Lost connection to room.", "âš ï¸ Connection Error");
                });
                return unsubscribeRoom;
            },

            listenToActiveRooms(callback) {
                if (!db) return () => {};
                const q = query(collection(db, ROOM_COLLECTION));
                // Clear existing listener if any
                if (unsubscribeRooms) { unsubscribeRooms(); unsubscribeRooms = null; }

                unsubscribeRooms = onSnapshot(q, (snapshot) => {
                    const rooms = snapshot.docs.map(doc => ({ roomCode: doc.id, ...doc.data() }));
                    callback(rooms);
                }, (error) => {
                    console.error("Error listening to rooms: ", error);
                });
                return unsubscribeRooms;
            }
        };


        // --- GAME LOGIC (RUNS ON STATE UPDATE) ---

        const processMatchRequests = (room) => {
            if (room.matchRequests.length === 0) return null; // No updates needed
            
            let newRoom = { ...room };
            let newBoard = [...room.board];
            let newPlayers = [...room.players];
            let newFlippedCards = [...room.flippedCards];
            let nextPlayerId = room.currentPlayerId;
            let chatUpdate = [];

            // Only process the oldest request
            const request = newRoom.matchRequests[0];
            const cardIndex = request.cardIndex;
            const flipperId = request.playerId;

            const isTurn = flipperId === newRoom.currentPlayerId;
            const card = newBoard[cardIndex];
            
            const isAlreadyFlipped = newFlippedCards.some(f => f.id === card.id);
            
            if (card.isMatched || isAlreadyFlipped) {
                // Invalid flip, just remove the request
            } else if (isTurn && newFlippedCards.length < 2) {
                
                // Flip the card
                newBoard[cardIndex] = { ...card, isFlipped: true };
                newFlippedCards.push(newBoard[cardIndex]);

                if (newFlippedCards.length === 2) {
                    const [card1, card2] = newFlippedCards;
                    
                    if (card1.icon === card2.icon) {
                        // MATCH!
                        newBoard[card1.id] = { ...newBoard[card1.id], isMatched: true, isFlipped: true };
                        newBoard[card2.id] = { ...newBoard[card2.id], isMatched: true, isFlipped: true };
                        
                        newPlayers = newPlayers.map(p => 
                            p.id === flipperId ? { ...p, score: p.score + 1 } : p
                        );
                        chatUpdate.push({ sender: 'SYSTEM', message: `${flipperId} scored a match! They get another turn.`, timestamp: Date.now() });
                        
                        newFlippedCards = []; // Clear for next pair
                        
                        // Check for win condition
                        if (newBoard.every(c => c.isMatched)) {
                            newRoom.status = 'finished';
                            chatUpdate.push({ sender: 'SYSTEM', message: `Game Over!`, timestamp: Date.now() });
                        }

                    } else {
                        // NO MATCH.
                        
                        // Change turn
                        const currentPlayerIndex = newPlayers.findIndex(p => p.id === flipperId);
                        const nextIndex = (currentPlayerIndex + 1) % newPlayers.length;
                        nextPlayerId = newPlayers[nextIndex].id;
                        
                        // Flip cards back immediately in state. The UI will handle the visual delay.
                        newBoard[card1.id] = { ...newBoard[card1.id], isFlipped: false };
                        newBoard[card2.id] = { ...newBoard[card2.id], isFlipped: false };

                        chatUpdate.push({ sender: 'SYSTEM', message: `${flipperId} missed. It is now ${nextPlayerId}'s turn.`, timestamp: Date.now() });
                        newFlippedCards = []; // Clear for next player
                    }
                }
            }
            
            // 2. Prepare the update document
            const updateData = {
                board: JSON.stringify(newBoard),
                players: newPlayers,
                currentPlayerId: nextPlayerId,
                flippedCards: newFlippedCards,
                // Crucially, remove the request we just processed
                matchRequests: newRoom.matchRequests.slice(1)
            };
            
            if(newRoom.status === 'finished') {
                 updateData.status = 'finished';
            }
            
            if(chatUpdate.length > 0) {
                updateData.chat = [...room.chat, ...chatUpdate];
            }
            
            return updateData;
        };


        // --- RENDERING AND UI UPDATES ---

        const renderApp = () => {
            const roomArea = document.getElementById('room-area');
            const gameContainer = document.getElementById('game-container');
            const boardEl = document.getElementById('game-board');
            const playersListEl = document.getElementById('players-list');
            const chatLogEl = document.getElementById('chat-log');
            const gameStatusEl = document.getElementById('game-status');
            
            if (!userId) {
                // Check if the fatal error message has already been rendered
                if (!firebaseConfig) return; 

                // Authentication still pending or failed
                roomArea.innerHTML = `<div class="p-6 bg-yellow-600 text-white rounded-lg text-center">
                    <p class="font-bold">Connecting to Multiplayer...</p>
                    <p class="text-sm">Please wait while we connect you to the service.</p>
                </div>`;
                gameContainer.classList.add('hidden');
                return;
            }

            // 1. Not in a room: Show room list/creation
            if (!AppState.currentRoom) {
                gameContainer.classList.add('hidden');
                roomArea.innerHTML = `
                    <div class="p-6 bg-gray-700 rounded-lg">
                        <h2 class="text-2xl font-bold text-white mb-4">Join or Create Game</h2>
                        <div class="space-y-4">
                            <!-- Create Room -->
                            <button onclick="window.createAndJoinRoom()" class="w-full p-3 bg-gold-600 hover:bg-gold-700 text-gray-900 font-extrabold rounded-lg transition duration-150 shadow-gold-500/50">
                                <i class="fas fa-plus mr-2"></i> Create New Room
                            </button>

                            <!-- Join by Code -->
                            <div class="flex space-x-2">
                                <input type="text" id="room-code-input" placeholder="Enter 4-letter code" maxlength="4" class="flex-grow p-3 rounded-lg bg-gray-800 text-white uppercase text-center font-bold tracking-widest border border-gray-600 focus:outline-none focus:ring-2 focus:ring-gold-400">
                                <button onclick="window.joinRoomByInput()" class="p-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg transition duration-150">
                                    Join
                                </button>
                            </div>
                            
                            <!-- View Active Rooms -->
                            <button onclick="window.showActiveRooms()" class="w-full p-3 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-150">
                                <i class="fas fa-list-ul mr-2"></i> View Active Rooms (${AppState.activeRooms.length})
                            </button>
                        </div>
                    </div>
                `;
                return;
            }
            
            // 2. In a room: Show game and chat
            gameContainer.classList.remove('hidden');
            const room = AppState.currentRoom;
            
            // Room Info Bar
            roomArea.innerHTML = `
                <div class="flex items-center justify-between p-4 bg-gray-700 rounded-lg mb-6">
                    <h2 class="text-xl font-bold text-white">
                        Room: <span class="text-gold-400 tracking-widest">${room.roomCode}</span>
                    </h2>
                    <div class="flex space-x-3">
                        <button onclick="window.copyRoomCode('${room.roomCode}')" class="p-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button onclick="window.leaveRoom()" class="p-2 bg-red-600 hover:bg-red-700 text-white rounded-lg text-sm font-semibold">
                            Leave
                        </button>
                    </div>
                </div>
            `;

            // --- Game Board Rendering ---
            boardEl.innerHTML = ''; // Clear board
            
            const isMyTurn = room.currentPlayerId === userId;
            const waitingForPair = room.flippedCards.length === 1;

            AppState.isMyTurn = isMyTurn;
            AppState.waitingForPair = waitingForPair;
            
            // Set grid columns dynamically based on number of cards
            const totalCards = room.board.length;
            let cols = 4;
            if (totalCards > 16) cols = 6;
            else if (totalCards <= 12) cols = 4;
            else cols = 5;
            boardEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;


            room.board.forEach((card, index) => {
                const cardEl = document.createElement('div');
                
                // Determine if this card is currently visible (either matched or one of the two flipped)
                const isCurrentlyFlipped = room.flippedCards.some(f => f.id === card.id);
                const isVisible = card.isMatched || isCurrentlyFlipped;

                cardEl.className = `card aspect-square rounded-lg shadow-xl cursor-pointer ${isVisible ? 'flipped' : ''} ${card.isMatched ? 'matched' : ''}`;
                
                let clickHandler = `window.handleCardClick(${index}, ${isVisible})`;

                // Apply a visual delay for non-matched cards that were just flipped, before they flip back
                if (isCurrentlyFlipped && !card.isMatched && room.flippedCards.length === 2) {
                     // If two cards are flipped and not matched, prevent further clicks until turn changes
                     cardEl.style.pointerEvents = 'none';
                     
                     // If it's a miss, we'll visually flip them back after a delay (handled by CSS/State change)
                     // In the state, they are immediately set to isFlipped=false by the 'host' logic.
                     // The visual flip back is handled by the removal of the 'flipped' class on the next render.
                } else if (card.isMatched) {
                    cardEl.style.pointerEvents = 'none';
                }
                
                cardEl.onclick = new Function(clickHandler);

                cardEl.innerHTML = `
                    <div class="card-inner">
                        <div class="card-face card-back">
                            <i class="fas fa-question text-xl text-white"></i>
                        </div>
                        <div class="card-face card-front">
                            ${card.icon}
                        </div>
                    </div>
                `;
                boardEl.appendChild(cardEl);
            });
            
            // --- Status Update ---
            if (room.status === 'finished') {
                const winner = room.players.sort((a, b) => b.score - a.score)[0];
                gameStatusEl.className = 'mt-4 p-3 bg-yellow-600 text-gray-900 rounded-lg text-center font-extrabold text-lg';
                gameStatusEl.textContent = `Game Finished! Winner: ${winner.id} with ${winner.score} matches!`;
            } else {
                gameStatusEl.className = 'mt-4 p-3 rounded-lg text-center font-semibold transition-colors duration-300';
                if (isMyTurn) {
                    gameStatusEl.textContent = "ðŸŸ¢ Your Turn! Click a card.";
                    gameStatusEl.classList.add('bg-green-600', 'text-white');
                    gameStatusEl.classList.remove('bg-gray-700');
                } else {
                    gameStatusEl.textContent = `ðŸ”´ Waiting for ${room.currentPlayerId}'s turn.`;
                    gameStatusEl.classList.remove('bg-green-600', 'text-white');
                    gameStatusEl.classList.add('bg-gray-700', 'text-white');
                }
            }


            // --- Player List Rendering ---
            playersListEl.innerHTML = '';
            document.getElementById('player-count').textContent = `(${room.players.length})`;
            room.players.sort((a, b) => b.score - a.score).forEach(player => {
                const isCurrentPlayer = player.id === userId;
                const isTurnPlayer = player.id === room.currentPlayerId;
                playersListEl.innerHTML += `
                    <li class="flex items-center justify-between p-2 rounded-md ${isTurnPlayer ? 'bg-gold-600 text-gray-900 font-bold shadow-md' : 'bg-gray-600'}">
                        <span class="truncate ${player.color}">
                            ${isTurnPlayer ? '<i class="fas fa-flag mr-1"></i>' : ''}
                            ${player.id} ${isCurrentPlayer ? '(You)' : ''}
                        </span>
                        <span class="font-bold text-lg ${isTurnPlayer ? 'text-gray-900' : 'text-white'}">${player.score}</span>
                    </li>
                `;
            });

            // --- Chat Log Rendering ---
            if (room.chat.length !== chatLogEl.children.length) {
                chatLogEl.innerHTML = room.chat.map(msg => {
                    const isSystem = msg.sender === 'SYSTEM';
                    const isMe = msg.sender === userId;
                    const senderClass = isSystem ? 'text-yellow-400' : (isMe ? 'text-blue-400' : 'text-red-400');
                    const senderName = isSystem ? 'System' : (isMe ? 'You' : msg.sender);
                    return `<p><span class="font-semibold ${senderClass}">${senderName}:</span> ${msg.message}</p>`;
                }).join('');
                // Scroll to bottom
                chatLogEl.scrollTop = chatLogEl.scrollHeight;
            }
            
            // --- Process Match Requests (runs only if I'm the designated "host" or first player) ---
            if (room.players.length > 0 && room.players[0].id === userId && room.matchRequests.length > 0) {
                 const updateData = processMatchRequests(room);
                 if (updateData) {
                    const roomRef = doc(db, ROOM_COLLECTION, room.roomCode);
                    updateDoc(roomRef, updateData).catch(e => {
                        console.error("Error processing match request:", e);
                    });
                 } else {
                     // If updateData is null, it means the request was invalid (e.g., card already flipped).
                     // We still need to clear the request queue.
                     const roomRef = doc(db, ROOM_COLLECTION, room.roomCode);
                     updateDoc(roomRef, { matchRequests: room.matchRequests.slice(1) }).catch(e => {
                         console.error("Error clearing invalid match request:", e);
                     });
                 }
            }
        };


        // --- UI ACTIONS ---

        window.handleCardClick = async (cardIndex, isVisible) => {
            if (!firebaseConfig) return showMessage("Multiplayer is disabled.", "Error");
            
            if (AppState.currentRoom.status === 'finished') {
                showMessage("The game is finished.", "Game Over");
                return;
            }
            if (!AppState.isMyTurn) {
                showMessage("It's not your turn!", "Wait");
                return;
            }
            if (AppState.currentRoom.flippedCards.length >= 2) {
                showMessage("Waiting for turn change...", "Wait");
                return;
            }
            if (isVisible) {
                showMessage("This card is already flipped or matched.", "Invalid Move");
                return;
            }

            // Send flip request to the database
            await MultiplayerService.flipCard(AppState.currentRoom.roomCode, cardIndex);
        };
        
        window.createAndJoinRoom = async () => {
            if (!firebaseConfig) return showMessage("Multiplayer is disabled.", "Error");
            try {
                const room = await MultiplayerService.createRoom();
                await window.joinRoom(room.roomCode);
                showMessage(`Created and joined room ${room.roomCode}!`, 'âœ… Connected');
            } catch (e) {
                console.error("Error creating room: ", e);
                showMessage("Failed to create room.", 'âŒ Error');
            }
        };

        window.showActiveRooms = async () => {
            if (!firebaseConfig) return showMessage("Multiplayer is disabled.", "Error");
            try {
                // Ensure we are listening to active rooms before opening modal
                if (!unsubscribeRooms) {
                    MultiplayerService.listenToActiveRooms((rooms) => { 
                        AppState.activeRooms = rooms; 
                        renderApp(); 
                        // Update list in modal if it's open
                        if (!document.getElementById('room-list-modal').classList.contains('hidden')) {
                             updateRoomListModal(rooms);
                        }
                    });
                }
                
                const rooms = AppState.activeRooms;
                updateRoomListModal(rooms);

                document.getElementById('room-list-modal').classList.remove('hidden');
            } catch (e) {
                 console.error("Error fetching rooms: ", e);
                 showMessage("Failed to load room list.", 'âŒ Error');
            }
        };
        
        const updateRoomListModal = (rooms) => {
             const listEl = document.getElementById('active-rooms-list');
             listEl.innerHTML = rooms.length === 0 
                ? '<li class="text-gray-400">No active rooms found.</li>'
                : rooms.map(room => `
                    <li class="flex items-center justify-between p-3 bg-gray-700 rounded-lg hover:bg-gray-600 transition">
                        <span class="font-bold text-white">${room.roomCode}</span>
                        <span class="text-sm text-gray-400">${room.players.length} players</span>
                        <button onclick="window.joinRoom('${room.roomCode}'); document.getElementById('room-list-modal').classList.add('hidden')" class="ml-4 p-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm">
                            Join
                        </button>
                    </li>
                `).join('');
        };
        
        // This is the core function to establish a real-time connection to a room
        window.joinRoom = async (code) => {
            if (!firebaseConfig) return showMessage("Multiplayer is disabled.", "Error");
            
            if (!userId) {
                showMessage("Not authenticated. Please wait.", 'âŒ Error');
                return;
            }
            // First, try to join (update player list if needed)
            try {
                 await MultiplayerService.joinRoom(code);
            } catch (e) {
                 console.error("Join attempt failed:", e);
                 showMessage(e.message, 'âŒ Error');
                 return;
            }

            // Start listening to the room for real-time updates
            MultiplayerService.listenToRoom(code, (roomData) => {
                if (roomData) {
                    // Simple check for new players joining/leaving
                    if (roomData.players.length !== lastPlayerCount && lastPlayerCount !== 0) {
                         showMessage(`Player count changed: ${roomData.players.length}`, 'ðŸ”” Update');
                    }
                    lastPlayerCount = roomData.players.length;
                    
                    AppState.currentRoom = roomData;
                    renderApp();
                } else if (AppState.currentRoom) {
                    // Room was deleted
                    window.leaveRoom();
                }
            });
            showMessage(`Joined room ${code}!`, 'âœ… Connected');
        };

        window.joinRoomByInput = async () => {
            if (!firebaseConfig) return showMessage("Multiplayer is disabled.", "Error");
            const val = document.getElementById('room-code-input').value.toUpperCase();
            if(val.length === 4) await window.joinRoom(val);
        };

        window.leaveRoom = async () => {
            if (unsubscribeRoom) { unsubscribeRoom(); unsubscribeRoom = null; }
            AppState.currentRoom = null;
            lastPlayerCount = 0;
            // The active rooms listener remains, so the app will return to the room selection screen automatically
            renderApp();
            showMessage("You left the room.", 'ðŸ‘‹ Disconnected');
        };

        window.copyRoomCode = (code) => {
            // Use execCommand for broader compatibility in some sandbox environments
            const tempInput = document.createElement('input');
            document.body.appendChild(tempInput);
            tempInput.value = code;
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            showMessage('Room code copied to clipboard!', 'ðŸ“‹ Copied');
        };

        window.sendChat = async (e) => {
            e.preventDefault();
            if (!firebaseConfig) return showMessage("Multiplayer is disabled.", "Error");
            
            const input = document.getElementById('chat-input');
            const msg = input.value;
            if(msg.trim() && AppState.currentRoom) {
                await MultiplayerService.sendMessage(AppState.currentRoom.roomCode, msg);
                input.value = '';
                // The onSnapshot listener will update AppState.currentRoom and call renderApp()
            }
        };

        // Initialize the application, which handles Firebase setup and authentication
        initApp();
        
    </script>
</body>
</html>
