<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Nexus - Multiplayer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        .text-gold-400 { color: #FFD700; }
        .bg-gold-600 { background-color: #FFC72C; }
        .hover\:bg-gold-700:hover { background-color: #FFB300; }
        .shadow-gold-500\/50 { box-shadow: 0 10px 15px -3px rgba(255, 199, 44, 0.5), 0 4px 6px -4px rgba(255, 199, 44, 0.5); }
        
        .shadow-rainbow {
            box-shadow: 
                0 0 10px rgba(0, 255, 255, 0.4),
                0 0 20px rgba(255, 215, 0, 0.4),
                0 0 30px rgba(255, 0, 255, 0.2);
        }

        @keyframes fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .confetti-piece {
            position: absolute;
            animation-name: fall;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            border-radius: 50%;
        }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen font-sans">

    <div id="app" class="min-h-screen flex flex-col">
        <div class="flex items-center justify-center h-screen">
            <div class="text-xl text-teal-400 animate-pulse">Initializing System...</div>
        </div>
    </div>

    <div id="modal-container"></div>
    <div id="confetti-container"></div>

    <script type="module">
        /*
         * PUZZLE NEXUS - Cross-Device Multiplayer Puzzle Game
         * Fully integrated with Firebase Firestore for Real-Time Gameplay
         */

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, collection, query, where, getDocs, runTransaction, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // GAME CONSTANTS
        const TOTAL_PUZZLES = 30;
        const STAGES_PER_PUZZLE = 10;
        const LEVELS_PER_STAGE = 20;

        const PUZZLE_NAMES = [
            "Sequential Memory Matrix", "Ultimate Riddle Challenge", "Three Gods Logic", 
            "Einstein's Riddle", "Knights & Knaves", "Monty Hall Simulator", 
            "River Crossing", "Balance Scale Detective", "Logic Grids", "Masyu Loops", 
            "Nonograms", "Rope Burning Timer", "Light Switch Puzzle", "Smudged Faces", 
            "Zebra Variants", "Pattern Recognition", "Cryptarithmetic", "Towers of Hanoi", 
            "Sliding Block Puzzle", "Pentominoes", "Sokoban", "Futoshiki", "Kakuro", 
            "Skyscrapers", "Hashiwokakero", "Black Box Logic", "Ami-gami", 
            "Stirling Numbers Challenge", "The Fifteen Puzzle", "Hidden Path Finder"
        ];

        // GLOBAL FIREBASE STATE
        let db, auth;
        let unsubscribeRoomListener = null;

        // APPLICATION STATE
        const AppState = {
            userId: null,
            appId: null,
            currentPage: 'home',
            selectedPuzzle: null,
            selectedStage: null,
            userProgress: null,
            activeRooms: [],
            currentRoom: null,
            isRoomHost: false,
            
            puzzleState: {
                timer: 0,
                isSolved: false,
                mistakes: 0,
                currentLevel: 0,
                matrix: { size: 3, sequence: [], userSequence: [], display: true },
                timerInterval: null
            },
            
            // Multiplayer specific local state
            multiplayerState: {
                status: 'waiting', // waiting, playing, spectator
                seed: 0
            }
        };

        // PSEUDO RANDOM GENERATOR (Seeded)
        // Ensures all players get the exact same puzzle configuration
        function sfc32(a, b, c, d) {
            return function() {
                a |= 0; b |= 0; c |= 0; d |= 0; 
                var t = (a + b | 0) + d | 0;
                d = d + 1 | 0;
                a = b ^ b >>> 9;
                b = c + (c << 3) | 0;
                c = (c << 21 | c >>> 11);
                c = c + t | 0;
                return (t >>> 0) / 4294967296;
            }
        }
        
        // UTILITY FUNCTIONS
        const generateRoomCode = () => {
            const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
            let code = "";
            for (let i = 0; i < 4; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        };
        
        function showMessage(msg, title = 'Notification') {
            const modalHtml = `
                <div class="fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center transition-opacity duration-300">
                    <div class="bg-gray-700 p-8 rounded-xl shadow-2xl max-w-sm w-full text-center border-t-4 border-teal-500 transform transition duration-300 scale-100">
                        <h4 class="text-2xl font-bold text-white mb-3">${title}</h4>
                        <p class="text-gray-300 mb-6">${msg}</p>
                        <button onclick="document.getElementById('modal-container').innerHTML = ''" 
                            class="bg-teal-600 hover:bg-teal-700 text-white px-6 py-2 rounded-lg font-semibold transition duration-300">
                            Close
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('modal-container').innerHTML = modalHtml;
        }

        function showConfetti() {
            const container = document.getElementById('confetti-container');
            container.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 50;">
                    ${Array.from({ length: 50 }).map(() => {
                        const size = Math.random() * 8 + 3;
                        const left = Math.random() * 100;
                        const animDelay = Math.random() * 2;
                        const duration = Math.random() * 3 + 2;
                        const color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        return `<div class="confetti-piece" style="width: ${size}px; height: ${size}px; left: ${left}vw; background-color: ${color}; animation-delay: ${animDelay}s; animation-duration: ${duration}s;"></div>`;
                    }).join('')}
                </div>
            `;
            setTimeout(() => { container.innerHTML = ''; }, 3000);
        }

        // --- DATA LAYER (Firestore) ---

        async function initializeProgress() {
            // Path: artifacts/{appId}/users/{userId}/data/progress
            const progressRef = doc(db, 'artifacts', AppState.appId, 'users', AppState.userId, 'data', 'progress');
            
            try {
                const docSnap = await getDoc(progressRef);
                
                if (docSnap.exists()) {
                    AppState.userProgress = docSnap.data();
                } else {
                    // Create new progress structure
                    AppState.userProgress = {
                        totalCompleted: 0,
                        puzzles: PUZZLE_NAMES.reduce((acc, name, index) => {
                            acc[index] = {
                                name,
                                currentStage: 0,
                                currentLevel: 0,
                                bestTime: 0,
                                highScore: 0,
                                levelsCompleted: 0,
                                stages: Array(STAGES_PER_PUZZLE).fill(0).map(() => ({
                                    levels: Array(LEVELS_PER_STAGE).fill(0).map(() => ({ 
                                        status: 'locked', 
                                        score: 0, 
                                        time: 0,
                                        stars: 0
                                    }))
                                }))
                            };
                            if (index === 0) {
                                acc[index].stages[0].levels[0].status = 'unlocked';
                            }
                            return acc;
                        }, {}),
                        achievements: []
                    };
                    await saveProgress();
                }
            } catch (err) {
                console.error("Error loading progress:", err);
                showMessage("Could not load save data. Playing offline mode.", "Sync Error");
            }
        }

        async function saveProgress() {
            if (!AppState.userId || !db) return;
            const progressRef = doc(db, 'artifacts', AppState.appId, 'users', AppState.userId, 'data', 'progress');
            await setDoc(progressRef, AppState.userProgress);
        }

        // --- MULTIPLAYER SERVICE (Firestore) ---

        const MultiplayerService = {
            async createRoom(mode) {
                const roomCode = generateRoomCode();
                // Path: artifacts/{appId}/public/data/rooms/{roomCode}
                const roomRef = doc(db, 'artifacts', AppState.appId, 'public', 'data', 'rooms', roomCode);
                
                const roomData = {
                    roomCode,
                    mode,
                    createdAt: Date.now(),
                    status: 'lobby', // 'lobby' or 'playing'
                    activePuzzleIdx: 0, // Default to first puzzle
                    gameSeed: Math.random(), // For synced RNG
                    players: [{ 
                        id: AppState.userId, 
                        name: `Player-${AppState.userId.substring(0, 4)}`, 
                        status: 'ready', 
                        score: 0,
                        isSpectator: false
                    }],
                    hostId: AppState.userId,
                    chat: []
                };

                await setDoc(roomRef, roomData);
                return roomData;
            },
            
            async joinRoom(code) {
                const roomRef = doc(db, 'artifacts', AppState.appId, 'public', 'data', 'rooms', code);
                
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomDoc = await transaction.get(roomRef);
                        if (!roomDoc.exists()) throw "ROOM_NOT_FOUND";
                        
                        const room = roomDoc.data();
                        
                        // Check if player is already in
                        if (!room.players.some(p => p.id === AppState.userId)) {
                            if (room.players.length >= 8) throw "ROOM_FULL"; // Increased cap for observers
                            
                            const isGameInProgress = room.status === 'playing';
                            
                            const newPlayer = {
                                id: AppState.userId,
                                name: `Player-${AppState.userId.substring(0, 4)}`,
                                status: isGameInProgress ? 'waiting' : 'ready',
                                score: 0,
                                isSpectator: isGameInProgress // Mark as spectator if joining mid-game
                            };
                            
                            const newPlayers = [...room.players, newPlayer];
                            transaction.update(roomRef, { players: newPlayers });
                            
                            const chatMsg = {
                                senderId: 'SYSTEM',
                                senderName: 'System',
                                text: `${newPlayer.name} joined${isGameInProgress ? ' (Waiting for next round)' : ''}!`,
                                timestamp: Date.now()
                            };
                            transaction.update(roomRef, { chat: arrayUnion(chatMsg) });
                        }
                    });
                    
                    return await this.getRoom(code);
                } catch (error) {
                    return typeof error === 'string' ? error : "JOIN_FAILED";
                }
            },
            
            async updateRoomSettings(code, settings) {
                // Settings can include: activePuzzleIdx, status, gameSeed
                const roomRef = doc(db, 'artifacts', AppState.appId, 'public', 'data', 'rooms', code);
                await updateDoc(roomRef, settings);
            },
            
            async updatePlayerScore(code, score) {
                const roomRef = doc(db, 'artifacts', AppState.appId, 'public', 'data', 'rooms', code);
                // Need to read-modify-write players array safely
                // For simplicity in this demo, we'll read then update, better to use transaction in prod
                const r = await this.getRoom(code);
                if(!r) return;
                
                const players = r.players.map(p => {
                    if(p.id === AppState.userId) return { ...p, score: score };
                    return p;
                });
                
                await updateDoc(roomRef, { players });
            },

            async sendMessage(code, message) {
                const roomRef = doc(db, 'artifacts', AppState.appId, 'public', 'data', 'rooms', code);
                const chatMsg = {
                    senderId: AppState.userId,
                    senderName: `Player-${AppState.userId.substring(0, 4)}`,
                    text: message,
                    timestamp: Date.now()
                };
                await updateDoc(roomRef, { chat: arrayUnion(chatMsg) });
            },
            
            async getActiveRooms() {
                const roomsRef = collection(db, 'artifacts', AppState.appId, 'public', 'data', 'rooms');
                // Only show rooms currently in lobby
                const q = query(roomsRef, where("status", "==", "lobby")); 
                const querySnapshot = await getDocs(q);
                
                const rooms = [];
                querySnapshot.forEach((doc) => {
                    rooms.push(doc.data());
                });
                return rooms;
            },
            
            async getRoom(code) {
                const roomRef = doc(db, 'artifacts', AppState.appId, 'public', 'data', 'rooms', code);
                const s = await getDoc(roomRef);
                return s.exists() ? s.data() : null;
            }
        };

        // INIT APP
        async function initApp() {
            try {
              // For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyB-3kAk-lMT3jTny2YIs2R1_0mG-tJlmJI",
  authDomain: "puzzlesapp.firebaseapp.com",
  projectId: "puzzlesapp",
  storageBucket: "puzzlesapp.firebasestorage.app",
  messagingSenderId: "303461259730",
  appId: "1:303461259730:web:a1790a976b6d58d71dd00b",
  measurementId: "G-8YEJEBX0NE"
};

                const appId = typeof __app_id !== 'undefined' ? __app_id : 'puzzle-nexus-default';
                AppState.appId = appId;
                
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                // Auth
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                // Wait for User
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        AppState.userId = user.uid;
                        await initializeProgress();
                        AppState.activeRooms = await MultiplayerService.getActiveRooms();
                        AppState.currentPage = 'home';
                        renderApp();
                    }
                });

            } catch (error) {
                console.error("Init Error", error);
                document.getElementById('app').innerHTML = `<div class="flex items-center justify-center h-screen text-red-500">Failed to initialize. Check console.</div>`;
            }
        }

        // ROOM STATE MANAGER
        function setupRoomListener(roomCode) {
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            
            const roomRef = doc(db, 'artifacts', AppState.appId, 'public', 'data', 'rooms', roomCode);
            
            unsubscribeRoomListener = onSnapshot(roomRef, (doc) => {
                if (doc.exists()) {
                    const roomData = doc.data();
                    const prevStatus = AppState.currentRoom ? AppState.currentRoom.status : null;
                    AppState.currentRoom = roomData;
                    AppState.isRoomHost = roomData.hostId === AppState.userId;

                    // Handle Game Start Transition
                    if (prevStatus === 'lobby' && roomData.status === 'playing') {
                        // Check if I am a player in this game
                        const myPlayer = roomData.players.find(p => p.id === AppState.userId);
                        if (myPlayer && !myPlayer.isSpectator) {
                            startMultiplayerGameInstance(roomData);
                        } else {
                            // I joined late or am a spectator
                            AppState.multiplayerState.status = 'spectator';
                            renderApp(); // Will show waiting screen
                        }
                    }
                    
                    // Handle Game End/Return to Lobby
                    if (prevStatus === 'playing' && roomData.status === 'lobby') {
                        AppState.currentPage = 'lobby';
                        AppState.multiplayerState.status = 'waiting';
                        renderApp();
                    }

                    // Refresh UI if we are in lobby or multiplayer game
                    if (AppState.currentPage === 'lobby' || AppState.currentPage === 'multiplayerGame') {
                        renderApp();
                    }
                } else {
                    showMessage("Room closed by host or expired.", "Disconnected");
                    window.leaveRoom(false);
                }
            });
        }

        function startMultiplayerGameInstance(roomData) {
            AppState.currentPage = 'multiplayerGame';
            AppState.multiplayerState.status = 'playing';
            
            // USE SEED FOR IDENTICAL BOARD
            // Seeding logic: Create a seeded RNG based on roomData.gameSeed
            const seedFunc = sfc32(roomData.gameSeed * 1000, roomData.gameSeed * 2000, roomData.gameSeed * 3000, roomData.gameSeed * 4000);

            // Initialize puzzle state for multiplayer
            const puzzleName = PUZZLE_NAMES[roomData.activePuzzleIdx];
            
            if (puzzleName === 'Sequential Memory Matrix') {
                AppState.puzzleState = {
                    timer: 0,
                    mistakes: 0,
                    isSolved: false,
                    currentLevel: 0,
                    matrix: generateMatrix(4, seedFunc), // Fixed difficulty for MP
                    timerInterval: setInterval(() => {
                        AppState.puzzleState.timer++;
                        const tEl = document.getElementById('timer-display');
                        if(tEl) tEl.innerText = AppState.puzzleState.timer + 's';
                    }, 1000)
                };
                
                // Show memorize phase
                renderApp();
                setTimeout(() => {
                    AppState.puzzleState.matrix.display = false;
                    renderApp();
                }, 3000); // 3 seconds to memorize in MP
            } else {
                // Placeholder setup for other games
                AppState.puzzleState = {
                    timer: 0,
                    mistakes: 0,
                    isSolved: false,
                    timerInterval: setInterval(() => {
                        AppState.puzzleState.timer++;
                        const tEl = document.getElementById('timer-display');
                        if(tEl) tEl.innerText = AppState.puzzleState.timer + 's';
                    }, 1000)
                };
            }
            
            renderApp();
        }

        // RENDER FUNCTIONS
        function renderHeader() {
            const pages = [
                { name: 'Home', key: 'home', icon: 'fa-home' },
                { name: 'Multiplayer', key: 'lobby', icon: 'fa-globe' },
                { name: 'Profile', key: 'profile', icon: 'fa-user' },
            ];

            return `
                <header class="bg-gray-800 shadow-xl sticky top-0 z-20 border-b border-teal-600/50">
                    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3 flex justify-between items-center">
                        <div class="flex items-center space-x-6">
                            <button onclick="window.navTo('home')" class="text-2xl sm:text-3xl font-extrabold text-teal-400 hover:text-teal-300 transition duration-300">
                                PUZZLE NEXUS
                            </button>
                            <nav class="hidden md:flex space-x-4">
                                ${pages.map(page => `
                                    <button onclick="window.navTo('${page.key}')" 
                                        class="px-3 py-2 rounded-lg font-medium transition duration-300 flex items-center gap-2 ${AppState.currentPage === page.key ? 'bg-teal-600 text-white shadow-md' : 'text-gray-300 hover:bg-gray-700 hover:text-white'}">
                                        <i class="fa-solid ${page.icon}"></i> ${page.name}
                                    </button>
                                `).join('')}
                            </nav>
                        </div>
                        <div class="text-xs text-gray-400 hidden sm:block">
                           User: ${AppState.userId ? AppState.userId.substring(0,6) : '...'}
                        </div>
                    </div>
                </header>
            `;
        }

        function renderHome() {
            if (!AppState.userProgress) return '<div class="p-10 text-center">Loading Data...</div>';

            const nextPuzzleIndex = Object.keys(AppState.userProgress.puzzles).find(i => {
                const p = AppState.userProgress.puzzles[i];
                return p.levelsCompleted < STAGES_PER_PUZZLE * LEVELS_PER_STAGE;
            }) || 0;

            const puzzles = Object.values(AppState.userProgress.puzzles).map((puzzle, index) => {
                const totalLevels = STAGES_PER_PUZZLE * LEVELS_PER_STAGE;
                const progress = Math.floor((puzzle.levelsCompleted / totalLevels) * 100);
                const isNext = parseInt(index) === parseInt(nextPuzzleIndex);
                
                return `
                    <div onclick="window.goToStageSelect(${index})" 
                        class="bg-gray-800 p-5 rounded-xl cursor-pointer transition transform duration-300 hover:scale-[1.03] ${isNext ? 'shadow-lg shadow-teal-400/50 ring-2 ring-teal-400' : 'hover:shadow-lg hover:shadow-gold-500/30'}">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-xl font-extrabold ${isNext ? 'text-teal-400' : 'text-white'}">${puzzle.name}</h3>
                            <div class="text-xs font-semibold px-2 py-1 rounded-full ${progress === 100 ? 'bg-green-600 text-white' : 'bg-gray-700 text-teal-400'}">
                                ${progress}%
                            </div>
                        </div>
                        <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                            <div class="h-full ${isNext ? 'bg-teal-500' : 'bg-yellow-500'}" style="width: ${progress}%"></div>
                        </div>
                    </div>
                `;
            }).join('');

            return `
                <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-10 w-full">
                    <section class="mb-12 p-6 bg-gray-800 rounded-xl shadow-lg border border-teal-600/50">
                        <h2 class="text-3xl font-bold text-yellow-400 mb-4">Quick Actions</h2>
                        <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
                            <button onclick="window.goToStageSelect(${nextPuzzleIndex})" class="flex-1 py-3 px-6 bg-teal-600 hover:bg-teal-700 text-white font-bold rounded-lg shadow-lg">
                                <i class="fa-solid fa-play mr-2"></i> Continue Solo
                            </button>
                            <button onclick="window.navTo('lobby')" class="flex-1 py-3 px-6 bg-gold-600 hover:bg-gold-700 text-gray-900 font-bold rounded-lg shadow-lg">
                                <i class="fa-solid fa-users mr-2"></i> Multiplayer Lobby
                            </button>
                        </div>
                    </section>
                    <section>
                        <h2 class="text-3xl font-bold text-white mb-6 border-b border-gray-700 pb-2">Solo Puzzles</h2>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            ${puzzles}
                        </div>
                    </section>
                </div>
            `;
        }

        function renderStageSelect() {
            const puzzle = AppState.userProgress.puzzles[AppState.selectedPuzzle];
            
            const stagesHtml = puzzle.stages.map((stage, index) => {
                const isUnlocked = index === 0 || puzzle.stages[index-1].levels.some(l => l.status === 'completed');
                const completedCount = stage.levels.filter(l => l.status === 'completed').length;
                const progress = Math.floor((completedCount / LEVELS_PER_STAGE) * 100);
                
                return `
                    <div onclick="${isUnlocked ? `window.goToLevelSelect(${index})` : ''}" 
                        class="p-5 rounded-xl shadow-lg transition transform duration-300 ${isUnlocked ? 'bg-gray-800 cursor-pointer hover:scale-[1.05] hover:shadow-yellow-500/50' : 'bg-gray-900 opacity-50 cursor-not-allowed'}">
                        <h3 class="text-2xl font-bold text-gold-400 mb-2">Stage ${index + 1}</h3>
                        <p class="text-sm text-gray-300">${isUnlocked ? 'Unlocked' : 'Locked'}</p>
                        <div class="mt-3">
                            <div class="h-1 bg-gray-700 rounded-full overflow-hidden">
                                <div class="h-full bg-teal-500" style="width: ${progress}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            return `
                <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-10 w-full">
                    <button onclick="window.navTo('home')" class="mb-6 flex items-center text-teal-400 hover:text-teal-300">
                        <i class="fa-solid fa-arrow-left mr-2"></i> Back to Puzzles
                    </button>
                    <h1 class="text-4xl font-extrabold text-white mb-8">${puzzle.name}</h1>
                    <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-5 gap-6">
                        ${stagesHtml}
                    </div>
                </div>
            `;
        }

        function renderLevelSelect() {
            const puzzle = AppState.userProgress.puzzles[AppState.selectedPuzzle];
            const stage = puzzle.stages[AppState.selectedStage];

            const levelsHtml = stage.levels.map((level, index) => {
                const isUnlocked = level.status === 'unlocked' || level.status === 'completed';
                const isCompleted = level.status === 'completed';
                const isLocked = !isUnlocked;
                let bgClass = isLocked ? 'bg-gray-900/50 cursor-not-allowed' : isCompleted ? 'bg-green-800/50 hover:bg-green-700/70 cursor-pointer' : 'bg-gray-800 hover:bg-gray-700 cursor-pointer';
                
                return `
                    <div onclick="${isUnlocked ? `window.startPuzzle(${index})` : ''}" 
                        class="p-3 rounded-xl shadow-lg transition transform duration-300 text-center ${bgClass}">
                        <div class="text-xl font-bold mb-1 ${isLocked ? 'text-gray-600' : 'text-white'}">${index + 1}</div>
                         ${isLocked ? '<span class="text-red-500">üîí</span>' : isCompleted ? '‚≠ê' : '‚ñ∂Ô∏è'}
                    </div>
                `;
            }).join('');

            return `
                <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-10 w-full">
                    <button onclick="window.goToStageSelect(${AppState.selectedPuzzle})" class="mb-6 flex items-center text-teal-400 hover:text-teal-300">
                        <i class="fa-solid fa-arrow-left mr-2"></i> Back to Stages
                    </button>
                    <h1 class="text-4xl font-extrabold text-white mb-2">${puzzle.name} - Stage ${AppState.selectedStage + 1}</h1>
                    <div class="grid grid-cols-4 sm:grid-cols-6 lg:grid-cols-10 gap-4 mt-8">
                        ${levelsHtml}
                    </div>
                </div>
            `;
        }

        function renderPuzzle() {
            // SOLO PLAY RENDER
            const puzzleName = PUZZLE_NAMES[AppState.selectedPuzzle];
            const { timer, mistakes, isSolved, matrix } = AppState.puzzleState;
            
            let gridHtml = '';
            if (puzzleName === 'Sequential Memory Matrix') {
                const { size, sequence, userSequence, display } = matrix;
                const cells = [];
                for(let r=0; r<size; r++) {
                    for(let c=0; c<size; c++) {
                        const pos = `${r}-${c}`;
                        const isInSequence = sequence.includes(pos);
                        const isClicked = userSequence.includes(pos);
                        
                        let cellClass = 'w-12 h-12 sm:w-16 sm:h-16 rounded-lg border-2 flex items-center justify-center font-bold text-xl ';
                        if (display) {
                            cellClass += isInSequence ? 'bg-teal-500 border-teal-400' : 'bg-gray-800 border-gray-700';
                        } else if (isSolved) {
                            cellClass += isInSequence ? 'bg-green-500 border-green-400' : 'bg-gray-800 border-gray-700';
                        } else {
                            cellClass += isClicked ? 'bg-yellow-500 border-yellow-400' : 'bg-gray-800 border-gray-700 hover:bg-gray-600 cursor-pointer';
                        }
                        cells.push(`<div onclick="window.handleGameClick(${r}, ${c})" class="${cellClass}">${isClicked ? '‚úì' : ''}</div>`);
                    }
                }
                gridHtml = `<div class="grid gap-2 p-4 rounded-xl bg-gray-700/50 mx-auto w-min" style="grid-template-columns: repeat(${size}, 1fr);">${cells.join('')}</div>`;
            } else {
                gridHtml = `<div class="text-center p-10 bg-gray-800 rounded-xl"><p>Placeholder for <b>${puzzleName}</b>.</p><button onclick="window.solvePuzzleSim()" class="bg-green-600 text-white px-4 py-2 mt-4 rounded">Win Simulation</button></div>`;
            }

            return `
                <div class="max-w-4xl mx-auto px-4 py-10 w-full text-center">
                    <button onclick="window.exitPuzzle()" class="mb-6 flex items-center text-teal-400 hover:text-teal-300">
                        <i class="fa-solid fa-arrow-left mr-2"></i> Exit
                    </button>
                    <h1 class="text-3xl font-extrabold text-white mb-6">${puzzleName}</h1>
                    <div class="flex justify-between items-center mb-8 p-4 bg-gray-800 rounded-xl shadow-inner max-w-lg mx-auto">
                        <div class="text-center w-1/3"><p class="text-xs text-gray-400">Time</p><p id="timer-display" class="text-2xl font-bold">${timer}s</p></div>
                        <div class="text-center w-1/3"><p class="text-xs text-gray-400">Mistakes</p><p class="text-2xl font-bold text-red-400">${mistakes}</p></div>
                    </div>
                    ${gridHtml}
                </div>
            `;
        }

        function renderMultiplayerGame() {
            // MULTIPLAYER GAME RENDER
            const room = AppState.currentRoom;
            
            // 1. LATE JOINER / SPECTATOR VIEW
            if (AppState.multiplayerState.status === 'spectator') {
                return `
                    <div class="max-w-4xl mx-auto px-4 py-20 w-full text-center">
                        <h1 class="text-4xl font-bold text-white mb-4">Game in Progress</h1>
                        <p class="text-xl text-gray-400 mb-8">Please wait for the next round...</p>
                        <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-teal-500 mx-auto mb-8"></div>
                        <div class="bg-gray-800 p-6 rounded-xl max-w-md mx-auto">
                             <h3 class="text-lg font-bold text-teal-400 mb-4">Current Leaderboard</h3>
                             ${room.players.map(p => `
                                <div class="flex justify-between py-2 border-b border-gray-700 last:border-0">
                                    <span>${p.name}</span>
                                    <span class="font-bold text-gold-400">${p.score}</span>
                                </div>
                             `).join('')}
                        </div>
                        ${AppState.isRoomHost ? `<button onclick="window.returnToLobby()" class="mt-8 bg-red-600 hover:bg-red-700 px-6 py-2 rounded text-white font-bold">End Game & Return to Lobby</button>` : ''}
                    </div>
                `;
            }

            // 2. ACTIVE PLAYER VIEW
            const puzzleName = PUZZLE_NAMES[room.activePuzzleIdx];
            const { timer, mistakes, isSolved, matrix } = AppState.puzzleState;
            
            // --- Shared Game Logic (Sequential Memory) ---
            let gameBoardHtml = '';
            if (puzzleName === 'Sequential Memory Matrix') {
                const { size, sequence, userSequence, display } = matrix;
                const cells = [];
                for(let r=0; r<size; r++) {
                    for(let c=0; c<size; c++) {
                        const pos = `${r}-${c}`;
                        const isInSequence = sequence.includes(pos);
                        const isClicked = userSequence.includes(pos);
                        
                        let cellClass = 'w-12 h-12 sm:w-16 sm:h-16 rounded-lg border-2 flex items-center justify-center font-bold text-xl ';
                        if (display) {
                            cellClass += isInSequence ? 'bg-teal-500 border-teal-400' : 'bg-gray-800 border-gray-700';
                        } else if (isSolved) {
                            cellClass += isInSequence ? 'bg-green-500 border-green-400' : 'bg-gray-800 border-gray-700';
                        } else {
                            cellClass += isClicked ? 'bg-yellow-500 border-yellow-400' : 'bg-gray-800 border-gray-700 hover:bg-gray-600 cursor-pointer';
                        }
                        cells.push(`<div onclick="window.handleMultiplayerClick(${r}, ${c})" class="${cellClass}">${isClicked ? '‚úì' : ''}</div>`);
                    }
                }
                gameBoardHtml = `<div class="grid gap-2 p-4 rounded-xl bg-gray-700/50 mx-auto w-min" style="grid-template-columns: repeat(${size}, 1fr);">${cells.join('')}</div>`;
            } else {
                gameBoardHtml = `
                    <div class="text-center p-10 bg-gray-800 rounded-xl">
                        <p class="mb-4">Multiplayer support for <b>${puzzleName}</b> coming soon.</p>
                        <p class="text-sm text-gray-400">Click below to simulate score update.</p>
                        <button onclick="window.simulateMultiplayerScore()" class="bg-green-600 text-white px-4 py-2 mt-4 rounded">Claim Victory (Sim)</button>
                    </div>
                `;
            }

            return `
                <div class="max-w-6xl mx-auto px-4 py-6 w-full flex flex-col md:flex-row gap-6">
                    <!-- GAME AREA -->
                    <div class="flex-grow text-center">
                         <div class="flex justify-between items-center mb-4">
                            ${AppState.isRoomHost ? `<button onclick="window.returnToLobby()" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded text-sm">Stop Game</button>` : '<div></div>'}
                            <h2 class="text-2xl font-bold text-white">${puzzleName}</h2>
                            <div></div>
                        </div>

                        <div class="flex justify-center gap-8 mb-6 bg-gray-800 p-4 rounded-xl">
                            <div><p class="text-xs text-gray-400">Timer</p><p id="timer-display" class="text-2xl font-bold">${timer}s</p></div>
                            <div><p class="text-xs text-gray-400">Mistakes</p><p class="text-2xl font-bold text-red-400">${mistakes}</p></div>
                            <div><p class="text-xs text-gray-400">Your Score</p><p class="text-2xl font-bold text-gold-400">${Math.max(0, 100 - (timer*0.5) - (mistakes*10)).toFixed(0)}</p></div>
                        </div>

                        ${gameBoardHtml}
                    </div>

                    <!-- LIVE SCOREBOARD -->
                    <div class="w-full md:w-64 bg-gray-800 p-4 rounded-xl h-fit">
                        <h3 class="font-bold border-b border-gray-700 pb-2 mb-4 text-teal-400">Live Scores</h3>
                        <div class="space-y-2">
                            ${room.players.sort((a,b) => b.score - a.score).map(p => `
                                <div class="flex items-center p-2 rounded ${p.id === AppState.userId ? 'bg-teal-900/50 ring-1 ring-teal-500' : 'bg-gray-700'}">
                                    <div class="w-2 h-2 rounded-full mr-2 ${p.isSpectator ? 'bg-gray-500' : 'bg-green-500'}"></div>
                                    <div class="flex-1 min-w-0">
                                        <p class="truncate text-sm font-medium">${p.name}</p>
                                        <p class="text-xs text-gold-400 font-bold">${p.score} pts</p>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function renderLobby() {
            if (AppState.currentRoom) {
                const r = AppState.currentRoom;
                return `
                    <div class="max-w-5xl mx-auto px-4 py-10 w-full">
                        <button onclick="window.leaveRoom()" class="mb-6 flex items-center text-teal-400 hover:text-teal-300">
                            <i class="fa-solid fa-arrow-left mr-2"></i> Leave Room
                        </button>
                        
                        <div class="bg-gray-800 p-6 rounded-xl border-l-4 border-teal-500 shadow-lg mb-8">
                            <div class="flex flex-col md:flex-row justify-between items-center gap-4">
                                <div>
                                    <h1 class="text-4xl font-extrabold text-white mb-1">Room: ${r.roomCode}</h1>
                                    <p class="text-gray-400 text-sm">Share this code with friends to play together.</p>
                                </div>
                                <div class="flex gap-4 items-center">
                                    ${AppState.isRoomHost ? `
                                        <div class="relative group">
                                            <select onchange="window.selectRoomPuzzle(this.value)" class="bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-teal-400 outline-none appearance-none pr-8 cursor-pointer hover:bg-gray-600 transition">
                                                ${PUZZLE_NAMES.map((name, idx) => `
                                                    <option value="${idx}" ${r.activePuzzleIdx == idx ? 'selected' : ''}>${name}</option>
                                                `).join('')}
                                            </select>
                                            <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-white">
                                                <i class="fa-solid fa-chevron-down text-xs"></i>
                                            </div>
                                        </div>
                                        <button onclick="window.startRoomGame()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg animate-pulse">
                                            START GAME
                                        </button>
                                    ` : `
                                        <div class="bg-gray-700 px-4 py-2 rounded text-center">
                                            <p class="text-xs text-gray-400 uppercase">Selected Game</p>
                                            <p class="font-bold text-teal-400">${PUZZLE_NAMES[r.activePuzzleIdx]}</p>
                                        </div>
                                        <div class="bg-gray-900 px-4 py-2 rounded border border-gray-700">
                                            <p class="text-sm text-gray-300">Waiting for Host...</p>
                                        </div>
                                    `}
                                </div>
                            </div>
                        </div>

                        <div class="grid md:grid-cols-2 gap-6">
                            <!-- Players List -->
                            <div class="bg-gray-800 p-6 rounded-xl shadow-lg">
                                <h3 class="font-bold border-b border-gray-700 pb-2 mb-4 flex justify-between">
                                    <span>Players</span>
                                    <span class="text-teal-400">${r.players.length}/8</span>
                                </h3>
                                <div class="space-y-2 max-h-80 overflow-y-auto pr-2">
                                    ${r.players.map(p => `
                                        <div class="flex items-center p-3 rounded-lg ${p.id === AppState.userId ? 'bg-teal-900/30 border border-teal-500/50' : 'bg-gray-700/50'}">
                                            <div class="w-3 h-3 rounded-full mr-3 ${p.status === 'ready' ? 'bg-green-500' : 'bg-yellow-500'}"></div>
                                            <span class="font-medium">${p.name}${p.id === AppState.userId ? ' (You)' : ''}</span>
                                            ${p.id === r.hostId ? '<span class="ml-2 text-xs bg-gold-600 text-black px-1 rounded font-bold">HOST</span>' : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Chat -->
                            <div class="bg-gray-800 p-6 rounded-xl flex flex-col h-96 shadow-lg">
                                <h3 class="font-bold border-b border-gray-700 pb-2 mb-2">Room Chat</h3>
                                <div id="chat-box" class="flex-1 overflow-y-auto mb-4 space-y-3 p-2">
                                    ${r.chat && r.chat.length === 0 ? '<p class="text-gray-500 text-sm text-center mt-10">Waiting for players...</p>' : r.chat.map(msg => `
                                        <div class="text-sm flex flex-col ${msg.senderId === AppState.userId ? 'items-end' : msg.senderId === 'SYSTEM' ? 'items-center' : 'items-start'}">
                                            ${msg.senderId === 'SYSTEM' ? 
                                                `<span class="text-xs text-gray-500 bg-gray-900 px-2 py-1 rounded-full border border-gray-700">${msg.text}</span>` :
                                                `<span class="text-xs text-gray-400 mb-1 ml-1">${msg.senderName}</span>
                                                 <span class="px-3 py-2 rounded-lg max-w-[85%] ${msg.senderId === AppState.userId ? 'bg-teal-600 text-white rounded-tr-none' : 'bg-gray-700 text-gray-200 rounded-tl-none'}">
                                                    ${msg.text}
                                                 </span>`
                                            }
                                        </div>
                                    `).join('')}
                                </div>
                                <form onsubmit="window.sendChat(event)" class="flex gap-2">
                                    <input type="text" id="chat-input" class="flex-1 bg-gray-900 border border-gray-600 rounded-lg px-4 py-2 text-white focus:border-teal-400 outline-none transition" placeholder="Type a message..." required>
                                    <button type="submit" class="bg-gold-600 hover:bg-gold-700 px-4 py-2 rounded-lg font-bold text-gray-900 transition"><i class="fa-solid fa-paper-plane"></i></button>
                                </form>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div class="max-w-6xl mx-auto px-4 py-10 w-full">
                        <h1 class="text-4xl font-extrabold text-white mb-2">Multiplayer Lobby</h1>
                        <p class="text-sm text-teal-400 mb-6 flex items-center gap-2">
                            <span class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></span>
                            Live Cross-Device Multiplayer
                        </p>
                        
                        <div class="bg-gray-800 p-8 rounded-xl mb-8 border border-gold-600/50 shadow-lg relative overflow-hidden">
                            <div class="absolute top-0 right-0 w-64 h-64 bg-teal-500/10 rounded-full blur-3xl -mr-16 -mt-16 pointer-events-none"></div>
                            
                            <h2 class="text-2xl font-bold text-gold-400 mb-6">Create or Join Room</h2>
                            <div class="flex flex-col md:flex-row gap-6">
                                <div class="flex-1 space-y-4">
                                    <button onclick="window.createRoom('Standard')" class="w-full py-4 bg-teal-600 hover:bg-teal-700 rounded-xl font-bold text-lg shadow-lg transition transform hover:-translate-y-1">
                                        Create New Room
                                    </button>
                                    <p class="text-xs text-gray-400 text-center">Create a room and invite friends via code.</p>
                                </div>
                                <div class="flex items-center justify-center text-gray-500 font-bold">OR</div>
                                <div class="flex-1 space-y-4">
                                    <div class="flex gap-2">
                                        <input id="room-code-input" type="text" maxlength="4" placeholder="ROOM CODE" class="flex-1 bg-gray-900 rounded-xl px-4 py-4 uppercase text-white border border-gray-600 focus:border-gold-400 outline-none text-center font-mono text-xl tracking-widest">
                                        <button onclick="window.joinRoomByInput()" class="bg-gold-600 hover:bg-gold-700 text-gray-900 font-bold px-8 rounded-xl shadow-lg transition">JOIN</button>
                                    </div>
                                    <p class="text-xs text-gray-400 text-center">Enter a 4-letter code from a host.</p>
                                </div>
                            </div>
                        </div>

                        <h2 class="text-2xl font-bold mb-4 flex items-center gap-2"><i class="fa-solid fa-list text-teal-400"></i> Open Rooms</h2>
                        <div class="space-y-3">
                            ${AppState.activeRooms.length === 0 ? 
                                '<div class="p-8 text-center bg-gray-800/50 rounded-xl border border-dashed border-gray-700"><p class="text-gray-500">No open lobbies found. Be the first to create one!</p></div>' : 
                                AppState.activeRooms.map(r => `
                                    <div class="flex justify-between items-center p-4 bg-gray-800 rounded-xl hover:bg-gray-750 transition border border-transparent hover:border-gray-600 shadow-sm">
                                        <div class="flex items-center gap-4">
                                            <div class="bg-gray-700 px-3 py-1 rounded text-teal-400 font-mono font-bold">${r.roomCode}</div>
                                            <div>
                                                <div class="font-bold text-white text-sm">Host: <span class="text-gray-400">Player-${r.hostId.substring(0,4)}</span></div>
                                                <div class="text-xs text-gray-500">Puzzle: ${PUZZLE_NAMES[r.activePuzzleIdx]}</div>
                                            </div>
                                        </div>
                                        <div class="flex items-center gap-4">
                                            <div class="text-xs text-gray-400"><i class="fa-solid fa-user"></i> ${r.players.length}/8</div>
                                            <button onclick="window.joinRoom('${r.roomCode}')" class="bg-teal-600 hover:bg-teal-700 px-4 py-2 rounded-lg font-bold text-sm shadow">Join</button>
                                        </div>
                                    </div>
                                `).join('')}
                        </div>
                    </div>
                `;
            }
        }
        
        function renderProfile() {
            if (!AppState.userProgress) return "Loading...";
            
            const completed = Object.values(AppState.userProgress.puzzles).filter(p => {
                const totalLevels = STAGES_PER_PUZZLE * LEVELS_PER_STAGE;
                return p.levelsCompleted === totalLevels;
            }).length;
            
            return `
                <div class="max-w-6xl mx-auto px-4 py-10 w-full">
                    <h1 class="text-4xl font-extrabold text-teal-400 mb-2">Profile</h1>
                    <p class="text-xl text-gray-400 mb-8">User: <span class="text-gold-400">${AppState.userId}</span></p>

                    <div class="grid md:grid-cols-3 gap-6 mb-8">
                        <div class="bg-gray-800 p-6 rounded-xl border-b-4 border-teal-500 shadow-lg">
                            <p class="text-gray-400 text-sm">Puzzles Mastered</p>
                            <p class="text-5xl font-extrabold text-white mt-2">${completed} / ${TOTAL_PUZZLES}</p>
                        </div>
                        <div class="bg-gray-800 p-6 rounded-xl border-b-4 border-yellow-500 shadow-lg">
                            <p class="text-gray-400 text-sm">Levels Completed</p>
                            <p class="text-5xl font-extrabold text-white mt-2">${AppState.userProgress.totalCompleted}</p>
                        </div>
                        <div class="bg-gray-800 p-6 rounded-xl border-b-4 border-red-500 shadow-lg">
                            <p class="text-gray-400 text-sm">Achievements</p>
                            <p class="text-5xl font-extrabold text-white mt-2">${AppState.userProgress.achievements.length}</p>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderApp() {
            const app = document.getElementById('app');
            app.innerHTML = '';
            
            app.innerHTML += renderHeader();

            let contentHtml = '';
            switch(AppState.currentPage) {
                case 'home': contentHtml = renderHome(); break;
                case 'stageSelect': contentHtml = renderStageSelect(); break;
                case 'levelSelect': contentHtml = renderLevelSelect(); break;
                case 'puzzle': contentHtml = renderPuzzle(); break;
                case 'lobby': contentHtml = renderLobby(); break;
                case 'multiplayerGame': contentHtml = renderMultiplayerGame(); break;
                case 'profile': contentHtml = renderProfile(); break;
                default: contentHtml = renderHome(); break;
            }
            
            const main = document.createElement('main');
            main.className = 'flex-grow';
            main.innerHTML = contentHtml;
            app.appendChild(main);
            
            // Auto-scroll chat
            if (AppState.currentPage === 'lobby' && AppState.currentRoom) {
                const box = document.getElementById('chat-box');
                if(box) setTimeout(() => box.scrollTop = box.scrollHeight, 50);
            }
        }

        // --- GAME LOGIC ---

        // SOLO LOGIC
        window.navTo = async (page) => { 
            AppState.currentPage = page; 
            if (page === 'lobby') {
                AppState.activeRooms = await MultiplayerService.getActiveRooms();
            }
            renderApp(); 
        };
        
        window.goToStageSelect = (puzzleIdx) => { 
            AppState.selectedPuzzle = puzzleIdx; 
            AppState.currentPage = 'stageSelect'; 
            renderApp(); 
        };
        
        window.goToLevelSelect = (stageIdx) => { 
            AppState.selectedStage = stageIdx; 
            AppState.currentPage = 'levelSelect'; 
            renderApp(); 
        };

        window.startPuzzle = (levelIdx) => {
            const gridSize = 3 + Math.floor(levelIdx / 5);
            AppState.puzzleState = {
                timer: 0,
                mistakes: 0,
                isSolved: false,
                currentLevel: levelIdx,
                matrix: generateMatrix(gridSize, Math.random),
                timerInterval: setInterval(() => {
                    AppState.puzzleState.timer++;
                    const tEl = document.getElementById('timer-display');
                    if(tEl) tEl.innerText = AppState.puzzleState.timer + 's';
                }, 1000)
            };
            AppState.currentPage = 'puzzle';
            renderApp();
            
            setTimeout(() => {
                AppState.puzzleState.matrix.display = false;
                renderApp();
            }, 2000);
        };

        window.exitPuzzle = () => {
            clearInterval(AppState.puzzleState.timerInterval);
            AppState.currentPage = 'levelSelect';
            renderApp();
        };

        function generateMatrix(size, randFunc) {
            const sequence = [];
            const maxCells = Math.min(8, Math.floor(size * size / 2));
            while (sequence.length < maxCells) {
                const r = Math.floor(randFunc() * size);
                const c = Math.floor(randFunc() * size);
                const pos = `${r}-${c}`;
                if (!sequence.includes(pos)) sequence.push(pos);
            }
            return { size, sequence, userSequence: [], display: true };
        }

        window.handleGameClick = (r, c) => {
            const { isSolved, matrix } = AppState.puzzleState;
            if (isSolved || matrix.display) return;
            
            const pos = `${r}-${c}`;
            if (matrix.sequence.includes(pos)) {
                if (!matrix.userSequence.includes(pos)) {
                    matrix.userSequence.push(pos);
                    if (matrix.userSequence.length === matrix.sequence.length) {
                        completePuzzle();
                    } else {
                        renderApp();
                    }
                }
            } else {
                AppState.puzzleState.mistakes++;
                showMessage('Wrong tile! Resetting...', 'Oops');
                // Reset user sequence in solo, regenerate in MP? For solo just reset display
                AppState.puzzleState.matrix.display = true;
                AppState.puzzleState.matrix.userSequence = [];
                renderApp();
                setTimeout(() => {
                    AppState.puzzleState.matrix.display = false;
                    renderApp();
                }, 1500);
            }
        };
        
        async function completePuzzle() {
            AppState.puzzleState.isSolved = true;
            clearInterval(AppState.puzzleState.timerInterval);
            showConfetti();
            
            const puzzle = AppState.userProgress.puzzles[AppState.selectedPuzzle];
            const stage = puzzle.stages[AppState.selectedStage];
            const level = stage.levels[AppState.puzzleState.currentLevel];
            
            const time = AppState.puzzleState.timer;
            const mistakes = AppState.puzzleState.mistakes;
            const score = Math.max(0, 100 - (time * 0.5) - (mistakes * 10));
            
            level.status = 'completed';
            level.score = Math.max(level.score, score);
            puzzle.levelsCompleted++;
            AppState.userProgress.totalCompleted++;
            
            // Unlock next
            const nextLevelIdx = AppState.puzzleState.currentLevel + 1;
            if (nextLevelIdx < LEVELS_PER_STAGE) stage.levels[nextLevelIdx].status = 'unlocked';
            
            await saveProgress();
            showMessage(`Solved in ${time}s!`, 'Victory!');
            renderApp();
        }

        window.solvePuzzleSim = () => completePuzzle();

        // --- MULTIPLAYER GAMEPLAY LOGIC ---

        window.selectRoomPuzzle = async (idx) => {
            if (AppState.currentRoom) {
                await MultiplayerService.updateRoomSettings(AppState.currentRoom.roomCode, { activePuzzleIdx: parseInt(idx) });
            }
        };

        window.startRoomGame = async () => {
            if (AppState.currentRoom) {
                await MultiplayerService.updateRoomSettings(AppState.currentRoom.roomCode, { 
                    status: 'playing',
                    gameSeed: Math.random() // Generate new seed for everyone
                });
            }
        };

        window.returnToLobby = async () => {
             if (AppState.currentRoom) {
                await MultiplayerService.updateRoomSettings(AppState.currentRoom.roomCode, { status: 'lobby' });
            }
        };

        window.handleMultiplayerClick = async (r, c) => {
            const { isSolved, matrix } = AppState.puzzleState;
            if (isSolved || matrix.display) return;

            const pos = `${r}-${c}`;
            if (matrix.sequence.includes(pos)) {
                if (!matrix.userSequence.includes(pos)) {
                    matrix.userSequence.push(pos);
                    // Update Score
                    const currentScore = Math.max(0, 100 - (AppState.puzzleState.timer * 0.5) - (AppState.puzzleState.mistakes * 10));
                    await MultiplayerService.updatePlayerScore(AppState.currentRoom.roomCode, Math.floor(currentScore));

                    if (matrix.userSequence.length === matrix.sequence.length) {
                        AppState.puzzleState.isSolved = true;
                        clearInterval(AppState.puzzleState.timerInterval);
                        showConfetti();
                        // Final score boost
                        await MultiplayerService.updatePlayerScore(AppState.currentRoom.roomCode, Math.floor(currentScore + 50));
                        renderApp();
                    } else {
                        renderApp();
                    }
                }
            } else {
                AppState.puzzleState.mistakes++;
                const currentScore = Math.max(0, 100 - (AppState.puzzleState.timer * 0.5) - (AppState.puzzleState.mistakes * 10));
                await MultiplayerService.updatePlayerScore(AppState.currentRoom.roomCode, Math.floor(currentScore));
                
                showMessage('Wrong tile! Try again.', 'Oops');
                AppState.puzzleState.matrix.userSequence = [];
                AppState.puzzleState.matrix.display = true;
                renderApp();
                setTimeout(() => {
                    AppState.puzzleState.matrix.display = false;
                    renderApp();
                }, 1500);
            }
        };

        window.simulateMultiplayerScore = async () => {
             await MultiplayerService.updatePlayerScore(AppState.currentRoom.roomCode, Math.floor(Math.random() * 100));
        }

        // MULTIPLAYER LOBBY HANDLERS
        window.createRoom = async (mode) => {
            try {
                const room = await MultiplayerService.createRoom(mode);
                AppState.currentRoom = room;
                setupRoomListener(room.roomCode);
                AppState.activeRooms = await MultiplayerService.getActiveRooms();
                renderApp();
            } catch (e) {
                console.error(e);
                showMessage("Failed to create room.", "Error");
            }
        };

        window.joinRoom = async (code) => {
            const res = await MultiplayerService.joinRoom(code);
            if (typeof res === 'string') {
                showMessage(res.replace(/_/g, ' '), '‚ùå Error');
            } else {
                AppState.currentRoom = res;
                setupRoomListener(code);
                renderApp();
            }
        };

        window.joinRoomByInput = async () => {
            const val = document.getElementById('room-code-input').value.toUpperCase();
            if(val.length === 4) await window.joinRoom(val);
        };

        window.leaveRoom = async () => {
            if (unsubscribeRoomListener) {
                unsubscribeRoomListener();
                unsubscribeRoomListener = null;
            }
            if(AppState.puzzleState.timerInterval) clearInterval(AppState.puzzleState.timerInterval);
            
            AppState.currentRoom = null;
            AppState.currentPage = 'lobby';
            AppState.activeRooms = await MultiplayerService.getActiveRooms();
            renderApp();
        };
        
        window.sendChat = async (e) => {
            e.preventDefault();
            const input = document.getElementById('chat-input');
            const msg = input.value;
            if(msg.trim()) {
                await MultiplayerService.sendMessage(AppState.currentRoom.roomCode, msg);
                input.value = '';
            }
        };

        // START
        initApp();
    </script>
</body>
</html>
